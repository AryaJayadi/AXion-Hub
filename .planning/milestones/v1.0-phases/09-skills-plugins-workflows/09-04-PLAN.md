---
phase: 09-skills-plugins-workflows
plan: 04
type: execute
wave: 2
depends_on:
  - "09-03"
files_modified:
  - src/features/workflows/api/use-workflow-detail.ts
  - src/features/workflows/api/use-workflow-mutations.ts
  - src/features/workflows/model/execution-store.ts
  - src/features/workflows/components/canvas/execution-overlay.tsx
  - src/features/workflows/components/run-history-row.tsx
  - src/features/workflows/components/nodes/base-workflow-node.tsx
  - src/features/workflows/components/canvas/node-config-panel.tsx
  - src/views/workflows/workflow-detail-view.tsx
  - src/views/workflows/workflow-results-view.tsx
  - app/(dashboard)/workflows/[workflowId]/page.tsx
  - app/(dashboard)/workflows/[workflowId]/results/page.tsx
autonomous: true
requirements:
  - WORK-03

must_haves:
  truths:
    - "User can view a saved workflow at /workflows/[workflowId] loaded into the canvas editor"
    - "User can edit a workflow's nodes and edges and save changes"
    - "User can run a workflow and see live execution overlay with colored node borders"
    - "User can click a node during a live run and see its input/output/error in the sidebar"
    - "User can view past execution results at /workflows/[workflowId]/results"
  artifacts:
    - path: "src/features/workflows/model/execution-store.ts"
      provides: "Zustand store tracking per-node execution state"
      min_lines: 40
    - path: "src/features/workflows/components/canvas/execution-overlay.tsx"
      provides: "Live run visualization with colored node borders"
      min_lines: 40
    - path: "src/views/workflows/workflow-results-view.tsx"
      provides: "Detailed past-run inspection page"
      min_lines: 50
    - path: "src/features/workflows/api/use-workflow-detail.ts"
      provides: "Hook to load a saved workflow by ID"
      min_lines: 30
  key_links:
    - from: "src/views/workflows/workflow-detail-view.tsx"
      to: "src/features/workflows/model/workflow-canvas-store.ts"
      via: "loadWorkflow hydrates canvas from saved data"
      pattern: "loadWorkflow"
    - from: "src/features/workflows/components/canvas/execution-overlay.tsx"
      to: "src/features/workflows/model/execution-store.ts"
      via: "reads per-node execution state for border colors"
      pattern: "useExecutionStore"
    - from: "src/features/workflows/components/canvas/node-config-panel.tsx"
      to: "src/features/workflows/model/execution-store.ts"
      via: "reads NodeExecutionState for selected node when isRunning=true"
      pattern: "useExecutionStore"
    - from: "app/(dashboard)/workflows/[workflowId]/page.tsx"
      to: "src/views/workflows/workflow-detail-view.tsx"
      via: "route page renders view with workflowId"
      pattern: "WorkflowDetailView"
---

<objective>
Build the workflow detail/edit/run page at /workflows/[workflowId] with canvas loading, save mutations, live execution overlay, and a dedicated results page for past run inspection.

Purpose: Users need to view, edit, run existing workflows and see execution results -- both live on the canvas and in a detailed results view.
Output: Workflow detail page loading saved data into the canvas, execution overlay with per-node status coloring, and results page for historical runs.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-skills-plugins-workflows/09-RESEARCH.md
@.planning/phases/09-skills-plugins-workflows/09-03-SUMMARY.md

Key patterns from 09-03:
- workflow-canvas-store.ts: loadWorkflow(id, name, nodes, edges) for hydrating canvas
- workflow-editor-view.tsx: WorkflowEditorView with ReactFlowProvider, palette, canvas, config panel
- All 12 node types registered in nodeTypes constant
- node-registry.ts: NODE_CATEGORIES with border colors per category
</context>

<tasks>

<task type="auto">
  <name>Task 1: Workflow detail hook, save mutation, execution store, and execution overlay</name>
  <files>
    src/features/workflows/api/use-workflow-detail.ts
    src/features/workflows/api/use-workflow-mutations.ts
    src/features/workflows/model/execution-store.ts
    src/features/workflows/components/canvas/execution-overlay.tsx
    src/features/workflows/components/run-history-row.tsx
  </files>
  <action>
    Build the data and execution layers:

    **use-workflow-detail.ts**: `useWorkflowDetail(workflowId)` TanStack Query hook that returns a WorkflowDefinition with full node/edge data for canvas hydration. Mock data: return one of the mock workflows from use-workflows.ts but with populated nodes (e.g., a trigger node + 2 action nodes + 1 condition node with edges connecting them, pre-positioned in a vertical flow). Use `queryKeys.workflows.detail(workflowId)`. `staleTime: 30_000`.

    **use-workflow-mutations.ts**: Mutations for workflow lifecycle:
    - `useSaveWorkflow()`: accepts { workflowId, name, nodes, edges } and "saves" (mock delay 300ms). Invalidates workflow detail and list queries on success. Shows sonner toast "Workflow saved".
    - `useRunWorkflow()`: accepts { workflowId, overridePayload?: string } and triggers a mock execution. The optional overridePayload allows users to edit the input payload before retrying a failed run (per locked decision). Returns a runId. On success, starts populating the execution store with simulated node state transitions (see execution-store for details).
    - `useWorkflowRuns(workflowId)`: query hook returning mock execution history (5-8 past runs with varied statuses, durations, timestamps).

    **execution-store.ts**: Zustand store for live execution tracking:
    - State: runId (string | null), nodeStates (Map<string, NodeExecutionState>), isRunning (boolean), startedAt (Date | null)
    - Actions:
      - startRun(runId, nodeIds): sets runId, isRunning=true, initializes all nodes as "pending"
      - updateNodeState(nodeId, state): update a single node's execution state
      - clearRun(): reset all state
      - simulateExecution(nodes): helper that simulates execution by iterating through node IDs with setTimeout delays (500ms-1500ms each), updating states from pending -> running -> success/error. Make ~80% succeed, ~20% error. This simulates what would come from WebSocket events in production.

    **execution-overlay.tsx**: "use client" component that integrates execution visualization into the canvas.
    - Read execution store state
    - Export `EXECUTION_BORDER_COLORS` mapping:
      - pending: "border-muted-foreground" (gray)
      - running: "border-blue-500 animate-pulse" (blue + pulse)
      - success: "border-green-500" (green)
      - error: "border-red-500" (red)
      - skipped: "border-muted-foreground/50" (faded gray)
    - Export `useNodeExecutionBorder(nodeId)` hook that returns the CSS class for a node's current execution state. If no execution running, return null. Custom nodes from Plan 03 should NOT be modified -- instead, the overlay approach works by:
      - Exporting a hook that each custom node can optionally use to get its execution border class
      - The hook reads from execution store and returns the appropriate border class
    - Export `ExecutionStatusBar`: a small bar component showing overall run progress (X/Y nodes complete, elapsed time, status). Renders at top of canvas area when isRunning=true.

    **run-history-row.tsx**: Expandable row component for run history:
    - Collapsed: shows run ID (truncated), status badge, duration, timestamp, trigger type
    - Expanded: shows per-node execution results (node name, status, duration, I/O preview)
    - Uses framer-motion AnimatePresence for expand/collapse animation
    - "Retry" button for failed runs: when clicked, opens a retry dialog/inline section with a `<Textarea>` pre-populated with the original run's input payload (JSON.stringify with pretty-print). User can edit the payload before confirming. Confirm button calls useRunWorkflow with optional `overridePayload` parameter. Cancel button closes the editor. This fulfills the locked decision: "Failed runs support retry with options: retry button plus ability to edit input payload before re-queuing."
    - "View Results" link to /workflows/[id]/results
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Verify execution store's simulateExecution correctly transitions nodes through pending -> running -> success/error states with delays.</verify>
  <done>Workflow detail hook returns canvas-ready data, save/run mutations work with mock delays, execution store simulates per-node state transitions, and execution overlay provides border color hooks and status bar.</done>
</task>

<task type="auto">
  <name>Task 2: Workflow detail page, results page, and route wiring</name>
  <files>
    src/views/workflows/workflow-detail-view.tsx
    src/views/workflows/workflow-results-view.tsx
    src/features/workflows/components/canvas/node-config-panel.tsx
    src/features/workflows/components/nodes/base-workflow-node.tsx
    app/(dashboard)/workflows/[workflowId]/page.tsx
    app/(dashboard)/workflows/[workflowId]/results/page.tsx
  </files>
  <action>
    Build the workflow detail and results views:

    **workflow-detail-view.tsx**: "use client" composition that extends the WorkflowEditorView from Plan 03:
    - Props: workflowId (string)
    - On mount: call useWorkflowDetail(workflowId), when data loads, call canvasStore.loadWorkflow(id, name, nodes, edges) to hydrate the canvas. Use useEffect with data dependency.
    - On unmount: call canvasStore.clearCanvas() and executionStore.clearRun() to prevent stale state (per research Pitfall 6).
    - Top bar additions beyond Plan 03's editor:
      - "Run" button (green, play icon): calls useRunWorkflow mutation, which calls executionStore.simulateExecution with the current nodes. Disabled when isRunning.
      - "Save" button: calls useSaveWorkflow with current store state (nodes, edges, name). Show loading spinner during save.
      - "Results" link: navigates to /workflows/[id]/results
      - isDirty indicator (yellow dot next to workflow name when unsaved changes exist)
    - Canvas: same three-column layout as WorkflowEditorView. The custom nodes use the useNodeExecutionBorder hook (exported from execution-overlay) to optionally show execution state borders. This requires updating the base-workflow-node.tsx from Plan 03 to call `useNodeExecutionBorder(id)` and merge the returned class into its border classes. If the hook returns null, use the default category border.
    - ExecutionStatusBar renders at top of canvas area when execution is running.
    - **Live I/O sidebar (locked decision):** When `isRunning` is true and a node is selected, the right sidebar (node-config-panel.tsx) must switch from showing config fields to showing the selected node's live execution I/O. Read `useExecutionStore` to get `nodeStates.get(selectedNodeId)` and display: status badge, input data (formatted JSON in a `<pre>` block), output data (formatted JSON), error message (if status is "error", red text), startedAt/completedAt timestamps. When `isRunning` becomes false OR no execution state exists for the selected node, revert to showing the normal config fields. This wiring is added to workflow-detail-view.tsx by passing an `isRunning` prop to the config panel.

    **node-config-panel.tsx** (modifying Plan 03's file): Add execution I/O display mode:
    - Accept new optional prop: `isRunning: boolean`
    - Import `useExecutionStore` from the execution store
    - When `isRunning` is true and a node is selected, read `NodeExecutionState` for that node from the execution store
    - If execution state exists for the selected node, render an "Execution" view instead of config fields:
      - Status badge (pending/running/success/error) with appropriate color
      - "Input" section: `<pre className="text-xs bg-muted rounded p-2 overflow-auto max-h-48">` containing `JSON.stringify(nodeExecutionState.input, null, 2)` or "No input" if null
      - "Output" section: same `<pre>` formatting for `nodeExecutionState.output` or "Waiting..." if node is pending/running
      - "Error" section (only if status is "error"): red-bordered box showing `nodeExecutionState.error`
      - Timing: startedAt, completedAt (if finished), duration
    - When `isRunning` is false, render normal config fields as before (Plan 03 behavior unchanged)

    **base-workflow-node.tsx** (modifying Plan 03's file): Import and call `useNodeExecutionBorder(id)` from execution-overlay.tsx. Merge the returned border class into the card wrapper's className, overriding the default category border when an execution border is active.
    - Loading state: show skeleton while useWorkflowDetail is fetching
    - Error/not found: show error message with back link

    Important: This view reuses the WorkflowCanvas and NodePalette from Plan 03. Two Plan 03 files need updates: `base-workflow-node.tsx` (execution border hook integration) and `node-config-panel.tsx` (execution I/O display mode when isRunning=true).

    **workflow-results-view.tsx**: "use client" page for /workflows/[workflowId]/results:
    - Props: workflowId (string)
    - PageHeader with workflow name, back link to /workflows/[workflowId]
    - Uses useWorkflowRuns(workflowId) to get past runs
    - Renders run list using RunHistoryRow components (expanded rows show per-node details)
    - Summary stats at top: total runs, success rate, average duration, last run time
    - Loading skeleton while fetching
    - Empty state if no runs yet

    **Route pages**:
    - `app/(dashboard)/workflows/[workflowId]/page.tsx`: async server component, `const { workflowId } = await params`, renders WorkflowDetailView with workflowId prop. Include generateMetadata.
    - `app/(dashboard)/workflows/[workflowId]/results/page.tsx`: async server component, same pattern, renders WorkflowResultsView.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Navigate to /workflows/[mockId] -- canvas loads with pre-positioned nodes and edges. Click Run -- nodes animate through pending/running/success states with colored borders. Click Save -- toast appears. Navigate to /workflows/[mockId]/results -- past runs display with expandable details.</verify>
  <done>Workflow detail page loads saved workflows into the canvas, Run button triggers simulated execution with live colored node borders, Save persists changes, and results page shows detailed history of past runs.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. /workflows/[mockId] loads a saved workflow into the canvas with pre-positioned nodes and edges
3. Editing nodes (move, connect, delete) marks the workflow as dirty
4. Save button persists changes and shows success toast
5. Run button triggers execution with nodes transitioning: gray -> blue pulse -> green/red
6. ExecutionStatusBar shows progress during execution
7. During a live run, clicking a node switches the right sidebar from config fields to execution I/O (input, output, error, timing)
8. When run completes, sidebar reverts to showing config fields
9. /workflows/[mockId]/results shows 5-8 past runs with expandable per-node details
10. Retry button on failed runs opens payload editor textarea pre-populated with original input
11. Navigating away clears execution state (no stale borders on return)
</verification>

<success_criteria>
User can view and edit a saved workflow at /workflows/[workflowId] with the same interactive canvas from /workflows/new, run the workflow and see live execution overlay with colored node borders (pending/running/success/error), and inspect past runs in detail at /workflows/[workflowId]/results.
</success_criteria>

<output>
After completion, create `.planning/phases/09-skills-plugins-workflows/09-04-SUMMARY.md`
</output>
