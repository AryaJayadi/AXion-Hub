---
phase: 04-real-time-chat
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/features/chat/lib/token-buffer.ts
  - src/features/chat/lib/chat-stream-subscriptions.ts
  - src/features/chat/components/chat-view.tsx
  - src/features/chat/components/message-list.tsx
  - src/features/chat/components/message-bubble.tsx
  - src/features/chat/components/streaming-lane.tsx
  - src/features/chat/components/streaming-lanes.tsx
  - src/features/chat/components/chat-input.tsx
  - src/features/gateway-connection/lib/event-bus.ts
autonomous: true
requirements:
  - CHAT-02
must_haves:
  truths:
    - "User can type a message in the chat input and send it to an agent"
    - "Agent response streams token-by-token with a blinking cursor"
    - "Streaming tokens render as live markdown via Streamdown"
    - "Multiple agents streaming simultaneously show in separate visual lanes"
    - "Message list auto-scrolls during streaming when user is at the bottom"
    - "Finalized stream content merges into the conversation message feed"
  artifacts:
    - path: "src/features/chat/lib/token-buffer.ts"
      provides: "useTokenBuffer hook with rAF-based flush"
      exports: ["useTokenBuffer"]
    - path: "src/features/chat/components/chat-view.tsx"
      provides: "Complete chat view with message list + streaming lanes + input"
      min_lines: 50
    - path: "src/features/chat/components/message-bubble.tsx"
      provides: "Single message with Streamdown markdown rendering"
      min_lines: 30
    - path: "src/features/chat/components/streaming-lanes.tsx"
      provides: "Multi-agent parallel streaming lane container"
      min_lines: 20
    - path: "src/features/chat/components/chat-input.tsx"
      provides: "Chat textarea with send button and attachment trigger"
      min_lines: 40
  key_links:
    - from: "src/features/chat/lib/chat-stream-subscriptions.ts"
      to: "src/features/chat/model/chat-store.ts"
      via: "EventBus subscription -> store actions"
      pattern: "eventBus\\.on.*useChatStore"
    - from: "src/features/chat/components/message-bubble.tsx"
      to: "streamdown"
      via: "Streamdown component with isAnimating prop"
      pattern: "Streamdown"
    - from: "src/features/chat/components/chat-input.tsx"
      to: "src/features/gateway-connection/lib/gateway-client.ts"
      via: "useGateway() -> gatewayClient.sendMessage()"
      pattern: "sendMessage"
---

<objective>
Build the real-time streaming chat experience: token buffer with rAF flush, Streamdown markdown rendering, message list with sticky-bottom auto-scroll, parallel streaming lanes for multi-agent rooms, chat input with send, and EventBus wiring.

Purpose: Delivers the core interaction loop -- user sends a message, agent responds with token-by-token streaming rendered as live markdown. This is the product's heartbeat.
Output: Full streaming chat view with token buffer, Streamdown rendering, multi-agent streaming lanes, chat input, and EventBus subscriptions.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-chat/04-RESEARCH.md
@.planning/phases/04-real-time-chat/04-01-SUMMARY.md

# Existing infrastructure to wire into
@src/features/gateway-connection/lib/event-bus.ts
@src/features/gateway-connection/lib/gateway-client.ts
@src/features/gateway-connection/index.ts
@src/app/providers/gateway-provider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token buffer, EventBus subscriptions, and extend event types</name>
  <files>
    src/features/chat/lib/token-buffer.ts
    src/features/chat/lib/chat-stream-subscriptions.ts
    src/features/gateway-connection/lib/event-bus.ts
  </files>
  <action>
    **1. Create `src/features/chat/lib/token-buffer.ts`:**
    Implement the `useTokenBuffer` hook exactly as specified in 04-RESEARCH.md Pattern 1:
    - Uses `useRef<TokenBuffer>` with `{ buffer: string, rafId: number | null, pending: boolean }`
    - `appendToken(token)` accumulates in buffer, schedules rAF if not pending
    - rAF callback flushes buffer via `onFlush(flushed)`, resets buffer and pending flag
    - `useEffect` cleanup cancels any pending rAF on unmount
    - `useCallback` wraps appendToken with `[onFlush]` dependency
    - **Stale closure mitigation:** Use a ref for onFlush to always call the latest version:
      ```typescript
      const onFlushRef = useRef(onFlush);
      onFlushRef.current = onFlush;
      ```
      Then call `onFlushRef.current(flushed)` in the rAF callback.
    - Export `useTokenBuffer` as named export.

    **2. Extend `src/features/gateway-connection/lib/event-bus.ts` KnownEvents:**
    Add tool call streaming events to the existing KnownEvents type (DO NOT remove existing events):
    ```typescript
    // Gateway tool call events (during agent response)
    "chat.tool.start": { sessionId: string; messageId: string; toolCallId: string; name: string; arguments: Record<string, unknown> };
    "chat.tool.progress": { sessionId: string; messageId: string; toolCallId: string; output: string };
    "chat.tool.end": { sessionId: string; messageId: string; toolCallId: string; output: string };
    "chat.tool.error": { sessionId: string; messageId: string; toolCallId: string; error: string };

    // Chat room lifecycle events
    "chat.room.created": { conversationId: string; type: "room" | "team"; agentIds: string[]; title: string };
    ```

    **3. Create `src/features/chat/lib/chat-stream-subscriptions.ts`:**
    A function `initChatStreamSubscriptions(eventBus: EventBus): () => void` that:
    - Subscribes to `chat.stream.start` → calls `useChatStore.getState().startStream(sessionId, agentId, agentName, messageId)` (agentId extracted from sessionId or a separate field -- use sessionId as conversationId for now since the gateway maps sessions to conversations)
    - Subscribes to `chat.stream.token` → calls `useChatStore.getState().appendToStream(laneKey, token)` where laneKey is `${sessionId}:agent` (simplified; in multi-agent rooms the event would include agentId)
    - Subscribes to `chat.stream.end` → calls `useChatStore.getState().finalizeStream(sessionId, "agent", fullText)`
    - Subscribes to `chat.tool.start` → calls `useChatStore.getState().addToolCallToStream(laneKey, toolCall)`
    - Subscribes to `chat.tool.end` → calls `useChatStore.getState().updateToolCallInStream(laneKey, toolCallId, { status: 'completed', output })`
    - Subscribes to `chat.tool.error` → calls `useChatStore.getState().updateToolCallInStream(laneKey, toolCallId, { status: 'error', error })`
    - Subscribes to `chat.room.created` → calls `useChatStore.getState().addConversation(...)` with the new room
    - Returns cleanup function that calls all unsubscribe functions
    - Import EventBus type from gateway-connection, useChatStore from chat store

    Export `initChatStreamSubscriptions` as named export.
  </action>
  <verify>
    Run `bun run build` — no TypeScript errors. Verify token-buffer.ts exports useTokenBuffer. Verify chat-stream-subscriptions.ts exports initChatStreamSubscriptions.
  </verify>
  <done>Token buffer hook with rAF flush pattern and stale closure mitigation ready. EventBus extended with tool call and room lifecycle events. Chat stream subscriptions wired to Zustand store actions.</done>
</task>

<task type="auto">
  <name>Task 2: Build chat view, message list, message bubble (Streamdown), streaming lanes, and chat input</name>
  <files>
    src/features/chat/components/chat-view.tsx
    src/features/chat/components/message-list.tsx
    src/features/chat/components/message-bubble.tsx
    src/features/chat/components/streaming-lane.tsx
    src/features/chat/components/streaming-lanes.tsx
    src/features/chat/components/chat-input.tsx
  </files>
  <action>
    **1. Create `src/features/chat/components/message-bubble.tsx`:**
    "use client" component rendering a single ChatMessage:
    - **Full-width blocks** per discretion recommendation (not bubbles) — consistent alignment for multi-agent rooms
    - User messages: subtle lighter background (`bg-muted/50`), user avatar on left, right-aligned name
    - AI messages: default background, agent avatar on left, agent name + model badge
    - System messages: centered, smaller text, muted color
    - AI message content rendered with `<Streamdown plugins={{ code }} isAnimating={isStreaming}>{content}</Streamdown>` from `streamdown` and `@streamdown/code`
    - User message content rendered as plain text (or basic markdown if desired)
    - Props: `message: ChatMessage`, `isStreaming?: boolean | undefined`
    - Timestamp rendered as client-only component (use `useState(false)` + `useEffect(() => setMounted(true))` pattern to avoid hydration mismatch). Use `formatDistanceToNow(message.timestamp, { addSuffix: true })` from date-fns.
    - Avatar from `@/shared/ui/avatar` with fallback initials
    - Role indicator: "You" for user, agent name for assistant

    **2. Create `src/features/chat/components/streaming-lane.tsx`:**
    "use client" component rendering a single agent's streaming area:
    - Props: `lane: StreamingLane`
    - Shows agent avatar + name header
    - Renders streaming content with `<Streamdown isAnimating={lane.isActive} plugins={{ code }}>{lane.accumulatedText}</Streamdown>`
    - Below the text: if lane.toolCalls has entries, show a brief "Using tools..." indicator (full tool call visualization in 04-03)
    - Subtle left border with agent-specific color (use a hash of agentId to pick from a small palette)

    **3. Create `src/features/chat/components/streaming-lanes.tsx`:**
    "use client" component for multi-agent parallel streaming display:
    - Props: `conversationId: string`
    - Uses `useStreamingLanes(conversationId)` hook from chat store
    - If no active lanes: return null
    - Renders each lane in a `<StreamingLane>` with a top border separator and vertical gap
    - Container: `flex flex-col gap-3 border-t border-border/50 pt-3`

    **4. Create `src/features/chat/components/chat-input.tsx`:**
    "use client" component with message textarea and send:
    - Native `<textarea>` (NOT contentEditable per research anti-pattern) with auto-resize on content
    - Props: `conversationId: string`, `onSend: (text: string) => void`, `disabled?: boolean | undefined`
    - Send button (Send icon from lucide-react) — enabled when text is non-empty and not disabled
    - Paperclip icon button for attachment trigger (placeholder for 04-03 media support)
    - Submit on Enter (without Shift), Shift+Enter for newline
    - Auto-resize textarea: `useRef<HTMLTextAreaElement>`, on input set `style.height = 'auto'` then `style.height = scrollHeight + 'px'`, max-height 200px with overflow-y auto
    - Draft preservation: on text change, call `useChatStore.getState().saveDraft(conversationId, text)`. On mount, load draft via `useChatStore.getState().getDraft(conversationId)`.
    - Placeholder text: "Type a message..." or "Type / for commands" (hint for slash commands in 04-04)
    - Tailwind styling: rounded border, focus ring, padding for textarea; icon buttons on the right side

    **5. Create `src/features/chat/components/message-list.tsx`:**
    "use client" component rendering the scrollable message feed:
    - Props: `conversationId: string`
    - Uses `useConversationMessages(conversationId)` hook
    - Wraps messages in `ScrollArea` from `@/shared/ui/scroll-area` with `className="flex-1"`
    - Renders each message with `<MessageBubble message={msg} />` (isStreaming=false for finalized messages)
    - **Sticky-bottom auto-scroll:** Use `useRef` for the scroll container, track if user is near bottom (within 50px). On new messages or streaming lane changes, auto-scroll to bottom only if already at bottom. If user scrolled up, show a "New messages" button at bottom-right that scrolls to latest.
    - After messages: render `<StreamingLanes conversationId={conversationId} />` for any active streams
    - Loading state: `SkeletonList` from `@/shared/ui/loading-skeleton`
    - Empty state: EmptyState with "No messages yet. Start the conversation!" text

    **6. Create `src/features/chat/components/chat-view.tsx`:**
    "use client" component composing the full chat experience:
    - Props: `conversationId: string`, `agentId?: string | undefined`
    - Renders `<MessageList conversationId={conversationId} />` (flex-1 to fill space)
    - Renders `<ChatInput conversationId={conversationId} onSend={handleSend} />` at bottom
    - `handleSend`: uses `useGateway()` hook to get gatewayClient, calls `gatewayClient.sendMessage(agentId, text, conversationId)`. Also optimistically adds user message to store via `useChatStore.getState().addMessage(conversationId, { ... })` with a nanoid for optimistic ID.
    - Initialize chat stream subscriptions via `useEffect`: call `initChatStreamSubscriptions(eventBus)` from useGateway(), store cleanup in ref, call cleanup on unmount.
    - Layout: flex flex-col h-full (message list fills, input pinned to bottom)

    **7. Update view compositions from 04-01:**
    - `src/views/chat/agent-chat-view.tsx` — replace placeholder with `<ChatView conversationId={agentId} agentId={agentId} />`
    - `src/views/chat/team-chat-view.tsx` — replace placeholder with `<ChatView conversationId={conversationId} />`

    **TypeScript notes:** All optional props need `| undefined`. Import Streamdown and code plugin with try/catch or conditional rendering if SSR issues arise (Streamdown may need dynamic import with `{ ssr: false }` if it's client-only).
  </action>
  <verify>
    Run `bun run build` — no TypeScript errors. Verify all 6 component files exist. Verify chat-view.tsx imports and uses MessageList, ChatInput, StreamingLanes, and initChatStreamSubscriptions.
  </verify>
  <done>Complete streaming chat experience: messages render with Streamdown markdown, token buffer batches at rAF rate, multiple agents stream in separate visual lanes, chat input sends messages via GatewayClient, auto-scroll follows streaming, and EventBus subscriptions route stream events to Zustand store.</done>
</task>

</tasks>

<verification>
1. `bun run build` passes with no errors
2. ChatView renders message list + streaming lanes + input
3. MessageBubble renders AI messages via Streamdown with code highlighting
4. Token buffer accumulates tokens and flushes at rAF rate
5. Streaming lanes container shows separate visual areas per agent
6. Chat input submits on Enter, preserves draft on conversation switch
7. EventBus subscriptions wire stream/token/end events to store
</verification>

<success_criteria>
- Streamdown renders AI message markdown with live code highlighting
- Token buffer prevents re-render storms (rAF-based flush, not direct setState per token)
- Multi-agent streaming shows in separate visual lanes that merge on completion
- Chat input sends messages via GatewayClient with optimistic UI update
- Auto-scroll follows streaming when user is at bottom, preserves position when scrolled up
- EventBus stream events (start, token, end, tool.*) route to Zustand store
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-chat/04-02-SUMMARY.md`
</output>
