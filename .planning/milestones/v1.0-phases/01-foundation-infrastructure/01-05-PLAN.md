---
phase: 01-foundation-infrastructure
plan: 05
type: execute
wave: 3
depends_on:
  - 01-01
  - 01-04
files_modified:
  - src/features/gateway-connection/model/store.ts
  - src/features/gateway-connection/model/hooks.ts
  - src/app/providers/query-provider.tsx
  - src/app/providers/gateway-provider.tsx
  - src/app/providers/app-providers.tsx
  - src/shared/lib/query-keys.ts
autonomous: true
requirements:
  - INFR-09

must_haves:
  truths:
    - "Zustand connection store reflects WebSocket state changes from Event Bus in real time"
    - "TanStack Query provider is configured with sensible defaults for a WebSocket-driven dashboard"
    - "The connection store has a retry() action that triggers manual reconnection"
    - "Query key factory provides consistent, typed cache keys for all REST queries"
    - "The gateway provider initializes the WebSocket stack and subscribes the connection store to Event Bus events"
  artifacts:
    - path: "src/features/gateway-connection/model/store.ts"
      provides: "Zustand connection state store"
      exports: ["useConnectionStore"]
    - path: "src/features/gateway-connection/model/hooks.ts"
      provides: "React hooks for connection state"
      exports: ["useConnectionState", "useIsConnected"]
    - path: "src/app/providers/gateway-provider.tsx"
      provides: "Gateway stack initialization and cleanup"
      exports: ["GatewayProvider"]
    - path: "src/shared/lib/query-keys.ts"
      provides: "TanStack Query key factory"
      exports: ["queryKeys"]
  key_links:
    - from: "src/features/gateway-connection/model/store.ts"
      to: "src/features/gateway-connection/lib/event-bus.ts"
      via: "EventBus subscription on init"
      pattern: "eventBus\\.on"
    - from: "src/app/providers/gateway-provider.tsx"
      to: "src/features/gateway-connection/index.ts"
      via: "createGatewayStack factory"
      pattern: "createGatewayStack"
    - from: "src/app/providers/app-providers.tsx"
      to: "src/app/providers/gateway-provider.tsx"
      via: "provider composition"
      pattern: "GatewayProvider"
---

<objective>
Set up Zustand stores for real-time WebSocket state and TanStack Query for REST-fetched data, with the gateway provider that initializes the WebSocket stack at app startup.

Purpose: State management patterns must be established before any feature builds on them. Zustand handles real-time push state (connection status, agent presence), TanStack Query handles REST pull state (historical data, config). The gateway provider wires the WebSocket stack to React.
Output: Working state management patterns that subsequent features can follow, plus the gateway provider that initializes WebSocket communication.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand connection store, React hooks, and query key factory</name>
  <files>
    src/features/gateway-connection/model/store.ts
    src/features/gateway-connection/model/hooks.ts
    src/shared/lib/query-keys.ts
  </files>
  <action>
    1. Create `src/features/gateway-connection/model/store.ts` (per RESEARCH.md Pattern 4):

       ```typescript
       import { create } from 'zustand';
       import type { ConnectionState, ConnectionMode } from './types';
       import type { EventBus } from '../lib/event-bus';
       import type { WebSocketManager } from '../lib/ws-manager';

       interface ConnectionStore {
         // State
         state: ConnectionState;
         mode: ConnectionMode;
         reconnectAttempt: number;
         maxAttempts: number;
         error: string | null;

         // Internal refs (not reactive -- set once)
         _wsManager: WebSocketManager | null;

         // Actions
         retry: () => void;
         disconnect: () => void;
         setWsManager: (manager: WebSocketManager) => void;
       }

       export const useConnectionStore = create<ConnectionStore>((set, get) => ({
         state: 'disconnected',
         mode: 'local',
         reconnectAttempt: 0,
         maxAttempts: 5,
         error: null,
         _wsManager: null,

         retry: () => {
           const manager = get()._wsManager;
           if (manager) {
             manager.retry();
           }
         },

         disconnect: () => {
           const manager = get()._wsManager;
           if (manager) {
             manager.disconnect();
           }
         },

         setWsManager: (manager) => set({ _wsManager: manager }),
       }));
       ```

       Create a subscription initializer function (called once at app startup):
       ```typescript
       export function initConnectionStoreSubscriptions(eventBus: EventBus): () => void {
         const unsubs: Array<() => void> = [];

         unsubs.push(eventBus.on('ws.state', ({ state }) => {
           useConnectionStore.setState({ state });
         }));

         unsubs.push(eventBus.on('ws.reconnecting', ({ attempt, maxAttempts }) => {
           useConnectionStore.setState({ reconnectAttempt: attempt, maxAttempts });
         }));

         unsubs.push(eventBus.on('ws.failed', ({ reason }) => {
           useConnectionStore.setState({ error: reason });
         }));

         unsubs.push(eventBus.on('ws.connected', ({ mode }) => {
           useConnectionStore.setState({ mode, error: null, reconnectAttempt: 0 });
         }));

         // Return cleanup function
         return () => unsubs.forEach(fn => fn());
       }
       ```

    2. Create `src/features/gateway-connection/model/hooks.ts` with convenience React hooks:
       ```typescript
       import { useConnectionStore } from './store';

       // Derived state hooks (use selectors for minimal re-renders)
       export const useConnectionState = () => useConnectionStore((s) => s.state);
       export const useIsConnected = () => useConnectionStore((s) => s.state === 'connected');
       export const useIsReconnecting = () => useConnectionStore((s) => s.state === 'reconnecting');
       export const useConnectionMode = () => useConnectionStore((s) => s.mode);
       export const useReconnectInfo = () => useConnectionStore((s) => ({
         attempt: s.reconnectAttempt,
         maxAttempts: s.maxAttempts,
       }));
       export const useConnectionError = () => useConnectionStore((s) => s.error);
       export const useRetryConnection = () => useConnectionStore((s) => s.retry);
       ```

    3. Create `src/shared/lib/query-keys.ts` -- TanStack Query key factory:
       ```typescript
       // Query key factory for consistent cache management
       // Pattern: each domain has a root key, sub-keys for specific queries
       // Usage: queryKeys.agents.list() -> ['agents', 'list']
       //        queryKeys.agents.detail(id) -> ['agents', 'detail', id]

       export const queryKeys = {
         agents: {
           all: ['agents'] as const,
           lists: () => [...queryKeys.agents.all, 'list'] as const,
           list: (filters?: Record<string, unknown>) => [...queryKeys.agents.lists(), filters] as const,
           details: () => [...queryKeys.agents.all, 'detail'] as const,
           detail: (id: string) => [...queryKeys.agents.details(), id] as const,
         },
         sessions: {
           all: ['sessions'] as const,
           lists: () => [...queryKeys.sessions.all, 'list'] as const,
           list: (filters?: Record<string, unknown>) => [...queryKeys.sessions.lists(), filters] as const,
           details: () => [...queryKeys.sessions.all, 'detail'] as const,
           detail: (id: string) => [...queryKeys.sessions.details(), id] as const,
         },
         gateway: {
           all: ['gateway'] as const,
           health: () => [...queryKeys.gateway.all, 'health'] as const,
           config: () => [...queryKeys.gateway.all, 'config'] as const,
         },
         audit: {
           all: ['audit'] as const,
           lists: () => [...queryKeys.audit.all, 'list'] as const,
           list: (filters?: Record<string, unknown>) => [...queryKeys.audit.lists(), filters] as const,
         },
       } as const;
       ```

       This factory pattern ensures consistent cache keys across the app and enables precise cache invalidation (e.g., invalidate all agent queries, or just one agent's detail).

    4. Update the `src/features/gateway-connection/index.ts` barrel to also export the store, hooks, and subscription initializer.

    IMPORTANT architectural decisions (per RESEARCH.md):
    - Zustand for PUSH state (WebSocket events update stores directly)
    - TanStack Query for PULL state (REST API calls with caching/refetching)
    - Separate stores per feature domain (connection store, agent store, chat store)
    - Cross-feature communication through Event Bus, NOT cross-store imports
  </action>
  <verify>
    - TypeScript compiles all new files
    - `useConnectionStore.getState().state` returns 'disconnected' (initial state)
    - Simulating EventBus emissions updates the store state
    - Query key factory produces correct key arrays
    - All hooks are importable and return correct types
  </verify>
  <done>
    Zustand connection store created with state, mode, reconnect info, and retry action. Convenience hooks provide selector-based access for minimal re-renders. Query key factory established for consistent TanStack Query cache management. Store subscription initializer ready for gateway provider.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create gateway provider and integrate into app providers</name>
  <files>
    src/app/providers/gateway-provider.tsx
    src/app/providers/app-providers.tsx
  </files>
  <action>
    1. Create `src/app/providers/gateway-provider.tsx` (client component):

       This provider initializes the gateway WebSocket stack and wires it to React:

       ```typescript
       'use client';

       import { createContext, useContext, useEffect, useRef, type ReactNode } from 'react';
       import { createGatewayStack } from '@/features/gateway-connection';
       import { initConnectionStoreSubscriptions, useConnectionStore } from '@/features/gateway-connection/model/store';
       import type { GatewayClient } from '@/features/gateway-connection/lib/gateway-client';
       import type { EventBus } from '@/features/gateway-connection/lib/event-bus';

       interface GatewayContextValue {
         gatewayClient: GatewayClient;
         eventBus: EventBus;
       }

       const GatewayContext = createContext<GatewayContextValue | null>(null);

       export function useGateway(): GatewayContextValue {
         const ctx = useContext(GatewayContext);
         if (!ctx) throw new Error('useGateway must be used within GatewayProvider');
         return ctx;
       }

       export function GatewayProvider({ children }: { children: ReactNode }) {
         const stackRef = useRef<ReturnType<typeof createGatewayStack> | null>(null);

         // Initialize once
         if (!stackRef.current) {
           stackRef.current = createGatewayStack({
             url: process.env.NEXT_PUBLIC_GATEWAY_URL ?? 'ws://localhost:18789',
             token: '', // Token will be set after auth in Phase 2
             mode: (process.env.NEXT_PUBLIC_AXION_MODE as 'local' | 'remote') ?? 'local',
           });
         }

         const { eventBus, wsManager, gatewayClient } = stackRef.current;

         useEffect(() => {
           // Wire connection store to event bus
           const cleanup = initConnectionStoreSubscriptions(eventBus);

           // Store wsManager ref for retry action
           useConnectionStore.getState().setWsManager(wsManager);

           // Auto-connect if we have a gateway URL
           // In Phase 1, this may not connect (no gateway running) -- that is fine
           // The connection state will stay 'disconnected' or 'failed'
           const gatewayUrl = process.env.NEXT_PUBLIC_GATEWAY_URL;
           if (gatewayUrl) {
             wsManager.connect(gatewayUrl, '').catch(() => {
               // Connection failure is expected if no gateway is running
             });
           }

           return () => {
             cleanup();
             wsManager.disconnect();
           };
         }, [eventBus, wsManager]);

         return (
           <GatewayContext.Provider value={{ gatewayClient, eventBus }}>
             {children}
           </GatewayContext.Provider>
         );
       }
       ```

       NOTE: In Phase 1, the gateway provider will likely fail to connect since there is no OpenClaw Gateway running. That is expected. The connection state will show 'disconnected' or 'failed', and the UI will show the appropriate banner (when built in Phase 2). The important thing is the stack is initialized and ready.

    2. Update `src/app/providers/app-providers.tsx` to include GatewayProvider:
       ```typescript
       'use client';

       import type { ReactNode } from 'react';
       import { ThemeProvider } from './theme-provider';
       import { QueryProvider } from './query-provider';
       import { GatewayProvider } from './gateway-provider';
       import { Toaster } from 'sonner';

       export function AppProviders({ children }: { children: ReactNode }) {
         return (
           <ThemeProvider>
             <QueryProvider>
               <GatewayProvider>
                 {children}
                 <Toaster richColors position="bottom-right" />
               </GatewayProvider>
             </QueryProvider>
           </ThemeProvider>
         );
       }
       ```

       Provider order matters:
       - ThemeProvider (outermost -- theme needed by all)
       - QueryProvider (query client for data fetching)
       - GatewayProvider (WebSocket stack, depends on nothing above)

    3. Add NEXT_PUBLIC_ env vars for client-side gateway config. Update `.env.example` and `.env.local`:
       ```
       NEXT_PUBLIC_GATEWAY_URL=ws://localhost:18789
       NEXT_PUBLIC_AXION_MODE=local
       ```

    IMPORTANT: The GatewayProvider uses `useRef` to create the stack once (not on every render). The stack persists for the lifetime of the app. Cleanup happens on unmount.
  </action>
  <verify>
    - `bun run build` compiles without errors (the provider is a client component, builds OK even without gateway)
    - `bun run dev` starts without crashes (gateway connection failure is graceful, not a crash)
    - `useGateway()` hook is importable and returns the correct type
    - The connection store initial state is 'disconnected'
    - The Toaster renders in the bottom-right
  </verify>
  <done>
    Gateway provider initializes the WebSocket stack and wires it to React via context. App providers compose theme, query, gateway, and toast providers. Connection store subscribes to Event Bus for real-time state updates. The retry action is available for manual reconnection. All state management patterns are established and ready for feature development.
  </done>
</task>

</tasks>

<verification>
1. Zustand store reflects connection state changes when Event Bus events are emitted
2. TanStack Query provider wraps the app with sensible defaults
3. Gateway provider initializes the WebSocket stack without crashing (even without a gateway)
4. Query key factory produces consistent, hierarchical cache keys
5. All hooks return correct types and use selectors for performance
6. `bun run build` succeeds with all providers in place
</verification>

<success_criteria>
- Zustand connection store has state, mode, reconnectAttempt, error, retry(), disconnect()
- Store subscribes to Event Bus events via initConnectionStoreSubscriptions()
- React hooks provide selector-based access to connection state
- TanStack Query client configured with staleTime: 60s, refetchOnWindowFocus: false
- Query key factory covers agents, sessions, gateway, audit domains
- Gateway provider creates the stack once and cleans up on unmount
- App providers compose all providers in correct order
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-05-SUMMARY.md`
</output>
