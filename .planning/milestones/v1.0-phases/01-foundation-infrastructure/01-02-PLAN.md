---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - Dockerfile
  - docker-compose.yml
  - docker-compose.prod.yml
  - .dockerignore
  - .env.example
autonomous: true
requirements:
  - INFR-03

must_haves:
  truths:
    - "Running `docker compose up` starts AXion Hub, PostgreSQL, and Redis containers"
    - "PostgreSQL container passes health check and accepts connections on port 5432"
    - "Redis container passes health check and responds to PING on port 6379"
    - "AXion Hub container starts the Next.js dev server with hot reload working"
    - "Running `docker compose -f docker-compose.prod.yml up` starts production-optimized containers"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage bun build with dev and production targets"
      contains: "FROM oven/bun"
    - path: "docker-compose.yml"
      provides: "Development Docker Compose with all services and health checks"
      contains: "services"
    - path: "docker-compose.prod.yml"
      provides: "Production Docker Compose with optimized builds"
      contains: "services"
    - path: ".dockerignore"
      provides: "Docker build context exclusions"
      contains: "node_modules"
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build.*dockerfile"
    - from: "docker-compose.yml"
      to: ".env.example"
      via: "environment variables"
      pattern: "DATABASE_URL.*postgres"
---

<objective>
Create Docker Compose setup with PostgreSQL, Redis, and the AXion Hub Next.js application, with health checks, named volumes, and both development and production configurations.

Purpose: All services run in Docker containers so the full stack starts with one command (`docker compose up`). This is a locked user decision.
Output: Dockerfile, docker-compose.yml (dev), docker-compose.prod.yml (prod), .dockerignore
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-stage Dockerfile and .dockerignore</name>
  <files>
    Dockerfile
    .dockerignore
  </files>
  <action>
    1. Create `Dockerfile` with multi-stage bun build (per RESEARCH.md Pattern 8):

       **Stage: base** -- `FROM oven/bun:latest AS base`, WORKDIR /app

       **Stage: dev** -- FROM base AS dev
       - Copy package.json and bun.lock*
       - Run `bun install`
       - Copy everything else
       - CMD `["bun", "run", "dev"]`
       - EXPOSE 3000

       **Stage: deps** -- FROM base AS deps (production dependencies only)
       - Copy package.json and bun.lock*
       - Run `bun install --frozen-lockfile --production`

       **Stage: builder** -- FROM base AS builder
       - Copy package.json and bun.lock*
       - Run `bun install --frozen-lockfile`
       - Copy all source
       - Run `bun run build`

       **Stage: runner** -- FROM oven/bun:alpine AS runner (or `oven/bun:distroless` if available)
       - Set NODE_ENV=production
       - Create non-root user (nodejs group, nextjs user)
       - Copy standalone output from builder: `.next/standalone`, `.next/static`, `public`
       - Set ownership to nextjs:nodejs
       - USER nextjs
       - EXPOSE 3000
       - CMD `["bun", "server.js"]`

    2. Create `.dockerignore`:
       ```
       node_modules
       .next
       .git
       .planning
       .storybook
       storybook-static
       .env.local
       .env*.local
       *.md
       .claude
       ```

    NOTE: The Dockerfile must work with bun as the package manager. Do NOT use npm or yarn commands.
  </action>
  <verify>
    - `docker build --target dev -t axion-hub:dev .` builds successfully
    - `docker build --target runner -t axion-hub:prod .` builds successfully (may fail without DB -- that is OK, just check it gets past the install stage)
    - `.dockerignore` excludes node_modules and .next
  </verify>
  <done>
    Multi-stage Dockerfile builds dev and production images with bun. The .dockerignore prevents unnecessary files from entering the build context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker Compose dev and prod configurations with health checks</name>
  <files>
    docker-compose.yml
    docker-compose.prod.yml
    .env.example
  </files>
  <action>
    1. Create `docker-compose.yml` for development (per RESEARCH.md Pattern 8):

       **app service:**
       - Build from Dockerfile, target: dev
       - Ports: `${APP_PORT:-3000}:3000`
       - Volumes: bind mount `.:/app` for hot reload, anonymous volumes for `/app/node_modules` and `/app/.next` (prevent host overwrite per Pitfall 7)
       - Environment: DATABASE_URL, REDIS_URL, GATEWAY_URL, GATEWAY_TOKEN, AXION_MODE, NODE_ENV=development
       - depends_on: db (service_healthy), redis (service_healthy)
       - develop.watch: sync for ./src and ./app directories, rebuild on package.json change

       **db service (PostgreSQL 17):**
       - Image: `postgres:17-alpine`
       - Environment: POSTGRES_DB=axion, POSTGRES_USER=axion, POSTGRES_PASSWORD=axion
       - Ports: `${DB_PORT:-5432}:5432`
       - Volume: `pgdata:/var/lib/postgresql/data`
       - Healthcheck: `pg_isready -U axion`, interval 5s, timeout 5s, retries 5

       **redis service (Redis 7):**
       - Image: `redis:7-alpine`
       - Ports: `${REDIS_PORT:-6379}:6379`
       - Volume: `redisdata:/data`
       - Command: `redis-server --appendonly yes` (enable AOF persistence)
       - Healthcheck: `redis-cli ping`, interval 5s, timeout 5s, retries 5

       **Named volumes:** pgdata, redisdata

    2. Create `docker-compose.prod.yml` for production:
       - Same services but app builds target: runner
       - No bind mount volumes on app (uses built image)
       - Set NODE_ENV=production
       - Add restart: unless-stopped to all services
       - Add memory limits if appropriate
       - PostgreSQL password should reference env var: `${POSTGRES_PASSWORD:-axion}`

    3. Update `.env.example` (from 01-01) to add Docker-specific vars:
       ```
       # Application
       APP_PORT=3000
       NODE_ENV=development

       # Database
       DATABASE_URL=postgres://axion:axion@db:5432/axion
       DB_PORT=5432
       POSTGRES_PASSWORD=axion

       # Redis
       REDIS_URL=redis://redis:6379
       REDIS_PORT=6379

       # Gateway
       GATEWAY_URL=ws://host.docker.internal:18789
       GATEWAY_TOKEN=
       AXION_MODE=local
       ```
       NOTE: In Docker, services reference each other by service name (db, redis), not localhost. Gateway URL uses `host.docker.internal` to reach the host machine where OpenClaw runs.

    IMPORTANT per user decisions: Full Docker setup -- everything in containers. One `docker compose up` starts it all.
  </action>
  <verify>
    - `docker compose config` validates the compose file without errors
    - `docker compose up -d` starts all three services (app, db, redis)
    - `docker compose ps` shows all services running and healthy
    - `docker compose exec db pg_isready -U axion` returns "accepting connections"
    - `docker compose exec redis redis-cli ping` returns "PONG"
    - `curl http://localhost:3000` returns the Next.js page (may take 30s on first start for bun install + dev server)
    - `docker compose down` stops all services cleanly
  </verify>
  <done>
    Docker Compose starts PostgreSQL, Redis, and AXion Hub with health checks. Dev mode has hot reload via bind mounts. Production mode uses optimized standalone build. All services accessible and healthy.
  </done>
</task>

</tasks>

<verification>
1. `docker compose up -d` starts all 3 services without errors
2. `docker compose ps` shows all services as healthy
3. PostgreSQL accepts connections on configured port
4. Redis responds to PING
5. AXion Hub dev server starts and serves pages
6. Hot reload works: editing a file in src/ reflects in the browser
7. `docker compose down -v` tears down cleanly including volumes
</verification>

<success_criteria>
- `docker compose up` starts AXion Hub + PostgreSQL + Redis with one command
- All services pass health checks within 30 seconds
- Development mode supports hot reload via bind mounts
- Production Dockerfile produces a minimal standalone image
- Environment variables are configurable via .env files
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
