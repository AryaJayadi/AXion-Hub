---
phase: 01-foundation-infrastructure
plan: 03
type: execute
wave: 3
depends_on:
  - 01-01
  - 01-02
files_modified:
  - drizzle.config.ts
  - src/shared/lib/db.ts
  - src/shared/lib/redis.ts
  - src/features/audit/model/schema.ts
  - src/shared/types/database.ts
  - drizzle/0000_initial.sql
autonomous: true
requirements:
  - INFR-02

must_haves:
  truths:
    - "Drizzle ORM connects to PostgreSQL via connection pool and can execute queries"
    - "Running `bun run db:generate` produces SQL migration files in the drizzle/ directory"
    - "Running `bun run db:migrate` applies migrations to the PostgreSQL database"
    - "The initial schema includes at least the audit_logs table with all required columns"
    - "The Redis client connects and can get/set values"
  artifacts:
    - path: "drizzle.config.ts"
      provides: "Drizzle Kit migration configuration"
      contains: "defineConfig"
    - path: "src/shared/lib/db.ts"
      provides: "Drizzle ORM instance with connection pool"
      exports: ["db"]
    - path: "src/shared/lib/redis.ts"
      provides: "ioredis singleton client"
      exports: ["redis"]
    - path: "src/features/audit/model/schema.ts"
      provides: "Audit logs table schema"
      contains: "auditLogs"
    - path: "drizzle/0000_initial.sql"
      provides: "Initial SQL migration"
      contains: "CREATE TABLE"
  key_links:
    - from: "src/shared/lib/db.ts"
      to: "pg.Pool"
      via: "connection pool"
      pattern: "new Pool"
    - from: "drizzle.config.ts"
      to: "src/**/schema.ts"
      via: "schema glob"
      pattern: "schema.*\\./src"
    - from: "src/shared/lib/redis.ts"
      to: "ioredis"
      via: "Redis constructor"
      pattern: "new.*Redis|IORedis"
---

<objective>
Set up Drizzle ORM with PostgreSQL connection pooling, define the initial database schema (including the audit_logs table), generate and run migrations, and create the Redis client singleton.

Purpose: The database and Redis are the persistence backbone for everything: audit logs, tasks, workflows, user accounts, job queues. Getting the ORM, migrations, and connection pooling right now prevents drift later.
Output: Working Drizzle ORM connection, initial schema with audit table, migration pipeline, and Redis client.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Drizzle ORM, create database connection pool, Redis client, and initial schema</name>
  <files>
    drizzle.config.ts
    src/shared/lib/db.ts
    src/shared/lib/redis.ts
    src/features/audit/model/schema.ts
    src/shared/types/database.ts
  </files>
  <action>
    1. Create `drizzle.config.ts` (per RESEARCH.md):
       ```typescript
       import { defineConfig } from 'drizzle-kit';

       export default defineConfig({
         dialect: 'postgresql',
         schema: './src/**/schema.ts',
         out: './drizzle',
         dbCredentials: {
           url: process.env.DATABASE_URL!,
         },
       });
       ```

    2. Create `src/shared/lib/db.ts` with connection pooling:
       ```typescript
       import { drizzle } from 'drizzle-orm/node-postgres';
       import { Pool } from 'pg';

       // Pool is created lazily -- only connects when first query is made
       const pool = new Pool({
         connectionString: process.env.DATABASE_URL,
         max: 20,
         idleTimeoutMillis: 30_000,
         connectionTimeoutMillis: 5_000,
       });

       export const db = drizzle({ client: pool });

       // Export pool for health check endpoints
       export { pool };
       ```
       NOTE: Do NOT import from env.ts here to avoid circular dependency and allow drizzle-kit CLI to use this file. Use process.env directly.

    3. Create `src/shared/lib/redis.ts` with ioredis singleton:
       ```typescript
       import IORedis from 'ioredis';

       // Lazy singleton -- created on first import
       export const redis = new IORedis(process.env.REDIS_URL ?? 'redis://localhost:6379', {
         maxRetriesPerRequest: null, // Required by BullMQ
         retryStrategy: (times) => Math.min(times * 50, 2000),
       });

       // For BullMQ -- it needs a separate connection per queue/worker
       export function createRedisConnection() {
         return new IORedis(process.env.REDIS_URL ?? 'redis://localhost:6379', {
           maxRetriesPerRequest: null,
         });
       }
       ```

    4. Create `src/features/audit/model/schema.ts` with the audit_logs table (per RESEARCH.md Pattern 6):
       ```typescript
       import { pgTable, serial, text, timestamp, jsonb, index } from 'drizzle-orm/pg-core';

       export const auditLogs = pgTable('audit_logs', {
         id: serial('id').primaryKey(),
         timestamp: timestamp('timestamp', { withTimezone: true }).defaultNow().notNull(),
         actor: text('actor').notNull(),
         actorType: text('actor_type').notNull(), // 'user' | 'system' | 'webhook'
         action: text('action').notNull(),         // 'create' | 'update' | 'delete'
         resourceType: text('resource_type').notNull(),
         resourceId: text('resource_id').notNull(),
         before: jsonb('before'),
         after: jsonb('after'),
         metadata: jsonb('metadata'),              // { ip, userAgent, correlationId }
         prevHash: text('prev_hash'),              // Hash chain for tamper detection
       }, (table) => [
         index('idx_audit_logs_timestamp').on(table.timestamp),
         index('idx_audit_logs_resource').on(table.resourceType, table.resourceId),
         index('idx_audit_logs_actor').on(table.actor),
       ]);
       ```

    5. Create `src/shared/types/database.ts` with shared database types:
       ```typescript
       import type { auditLogs } from '@/features/audit/model/schema';
       import type { InferInsertModel, InferSelectModel } from 'drizzle-orm';

       export type AuditLog = InferSelectModel<typeof auditLogs>;
       export type NewAuditLog = InferInsertModel<typeof auditLogs>;
       ```

    6. Create the `src/features/audit/` directory structure:
       - `src/features/audit/model/schema.ts` (created above)
       - `src/features/audit/index.ts` (public API barrel export)
  </action>
  <verify>
    - `cat drizzle.config.ts` shows valid config with schema glob
    - `cat src/shared/lib/db.ts` shows Pool with connectionString
    - `cat src/shared/lib/redis.ts` shows IORedis with maxRetriesPerRequest: null
    - TypeScript compiles: `bunx tsc --noEmit` passes for the new files
  </verify>
  <done>
    Drizzle ORM configured with PostgreSQL connection pool (max 20 connections). Redis client singleton created with BullMQ-compatible settings. Audit logs schema defined with timestamp, actor, action, resource, before/after diffs, metadata, and hash chain columns. Type exports for insert/select models available.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate and apply initial database migration</name>
  <files>
    drizzle/0000_initial.sql
    drizzle/meta/_journal.json
  </files>
  <action>
    1. Ensure Docker services are running: `docker compose up -d db redis`

    2. Wait for PostgreSQL to be healthy: `docker compose exec db pg_isready -U axion` (retry if needed).

    3. Generate migration from schema:
       ```bash
       DATABASE_URL=postgres://axion:axion@localhost:5432/axion bun run db:generate
       ```
       This reads all `**/schema.ts` files and produces SQL in `drizzle/`.

    4. Apply migration:
       ```bash
       DATABASE_URL=postgres://axion:axion@localhost:5432/axion bun run db:migrate
       ```

    5. Verify the table exists by running a query:
       ```bash
       docker compose exec db psql -U axion -d axion -c "\\dt"
       ```
       Should show the `audit_logs` table.

    6. Verify table structure:
       ```bash
       docker compose exec db psql -U axion -d axion -c "\\d audit_logs"
       ```
       Should show all columns with correct types.

    7. Test a basic insert+select round-trip. Create a temporary script `scripts/test-db.ts`:
       ```typescript
       import { db } from '../src/shared/lib/db';
       import { auditLogs } from '../src/features/audit/model/schema';

       async function main() {
         // Insert test record
         await db.insert(auditLogs).values({
           actor: 'system',
           actorType: 'system',
           action: 'create',
           resourceType: 'test',
           resourceId: 'test-1',
           metadata: { correlationId: 'test-run' },
         });

         // Read it back
         const rows = await db.select().from(auditLogs);
         console.log('Rows:', rows.length);
         console.log('First row:', rows[0]);

         // Clean up
         // (leave it or delete -- it is a test record)
         process.exit(0);
       }

       main().catch(console.error);
       ```
       Run: `DATABASE_URL=postgres://axion:axion@localhost:5432/axion bunx tsx scripts/test-db.ts`

       Delete the test script after verification.

    NOTE: The migration files in `drizzle/` are generated code and should be committed to git. They are the source of truth for database schema evolution.
  </action>
  <verify>
    - `ls drizzle/` shows at least one .sql migration file and a meta/ directory
    - `docker compose exec db psql -U axion -d axion -c "\\dt"` shows audit_logs table
    - `docker compose exec db psql -U axion -d axion -c "SELECT count(*) FROM audit_logs"` returns without error
    - The test script insert+select round-trip succeeds
  </verify>
  <done>
    Database migration pipeline works end-to-end. The audit_logs table exists in PostgreSQL with all columns, indexes, and correct types. Drizzle ORM can insert and read records. Migration files are committed and reproducible.
  </done>
</task>

</tasks>

<verification>
1. `bun run db:generate` produces migration SQL files
2. `bun run db:migrate` applies migrations without errors
3. PostgreSQL contains the audit_logs table with correct schema
4. Drizzle ORM insert + select round-trip works
5. Redis client connects and can execute commands
6. Connection pool respects max connection limit
</verification>

<success_criteria>
- Drizzle ORM connects to PostgreSQL via `pg.Pool` with configurable pool size
- `drizzle-kit generate` + `drizzle-kit migrate` workflow produces and applies migrations
- The audit_logs table has all columns: id, timestamp, actor, actorType, action, resourceType, resourceId, before, after, metadata, prevHash
- Redis client singleton connects with BullMQ-compatible settings
- Database types exported for use by other features
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md`
</output>
