---
phase: 01-foundation-infrastructure
plan: 04
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/features/gateway-connection/lib/ws-manager.ts
  - src/features/gateway-connection/lib/event-bus.ts
  - src/features/gateway-connection/lib/gateway-client.ts
  - src/features/gateway-connection/lib/reconnect.ts
  - src/features/gateway-connection/model/types.ts
  - src/features/gateway-connection/index.ts
  - src/entities/gateway-event/model/types.ts
  - src/entities/gateway-event/lib/parser.ts
  - src/entities/gateway-event/index.ts
autonomous: true
requirements:
  - INFR-04
  - INFR-05
  - INFR-06

must_haves:
  truths:
    - "WebSocketManager can connect to a WebSocket endpoint and maintain connection state (disconnected, connecting, authenticating, connected, reconnecting, failed)"
    - "The Event Bus dispatches typed events to subscribed handlers and supports wildcard listeners"
    - "The GatewayClient exposes clean async methods (getAgents, sendMessage, getHealth) that abstract the raw protocol"
    - "Reconnection uses exponential backoff with jitter and stops after max attempts with a manual retry option"
    - "Dual-mode detection works: local mode has filesystem access, remote mode gracefully degrades to WS-only"
    - "All gateway data passes through Zod validation before reaching feature code"
  artifacts:
    - path: "src/features/gateway-connection/lib/ws-manager.ts"
      provides: "WebSocket connection manager singleton"
      exports: ["WebSocketManager"]
      min_lines: 80
    - path: "src/features/gateway-connection/lib/event-bus.ts"
      provides: "Typed pub/sub event routing with wildcard support"
      exports: ["EventBus"]
      min_lines: 40
    - path: "src/features/gateway-connection/lib/gateway-client.ts"
      provides: "Abstraction layer over raw gateway protocol"
      exports: ["GatewayClient"]
      min_lines: 60
    - path: "src/features/gateway-connection/lib/reconnect.ts"
      provides: "Exponential backoff with jitter reconnection logic"
      exports: ["ReconnectStrategy"]
    - path: "src/features/gateway-connection/model/types.ts"
      provides: "Connection state machine types"
      contains: "ConnectionState"
    - path: "src/entities/gateway-event/model/types.ts"
      provides: "Discriminated union of all gateway frame types"
      contains: "GatewayFrame"
    - path: "src/entities/gateway-event/lib/parser.ts"
      provides: "Zod schemas for gateway frame validation"
      contains: "GatewayFrameSchema"
  key_links:
    - from: "src/features/gateway-connection/lib/ws-manager.ts"
      to: "src/features/gateway-connection/lib/event-bus.ts"
      via: "event dispatch on message received"
      pattern: "eventBus\\.emit"
    - from: "src/features/gateway-connection/lib/gateway-client.ts"
      to: "src/features/gateway-connection/lib/ws-manager.ts"
      via: "delegates request/response to WS manager"
      pattern: "ws\\.request"
    - from: "src/features/gateway-connection/lib/gateway-client.ts"
      to: "src/entities/gateway-event/lib/parser.ts"
      via: "validates gateway responses with Zod"
      pattern: "parse|safeParse"
    - from: "src/features/gateway-connection/lib/ws-manager.ts"
      to: "src/features/gateway-connection/lib/reconnect.ts"
      via: "delegates reconnection timing"
      pattern: "reconnect|backoff"
---

<objective>
Build the WebSocket Manager singleton, typed Event Bus, gateway abstraction layer (GatewayClient), reconnection strategy, and dual-mode connection support for communicating with the OpenClaw Gateway.

Purpose: This is the single most architecturally critical piece. Every feature that shows live agent data, sends commands, or receives events flows through this layer. Getting the protocol right (raw WebSocket, NOT Socket.IO) and the abstraction right (clean API that hides protocol details) is essential.
Output: A complete gateway communication stack that other features consume via GatewayClient methods and EventBus subscriptions.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gateway event types, Zod parsers, Event Bus, and reconnection strategy</name>
  <files>
    src/entities/gateway-event/model/types.ts
    src/entities/gateway-event/lib/parser.ts
    src/entities/gateway-event/index.ts
    src/features/gateway-connection/lib/event-bus.ts
    src/features/gateway-connection/lib/reconnect.ts
    src/features/gateway-connection/model/types.ts
  </files>
  <action>
    1. Create `src/entities/gateway-event/model/types.ts` with gateway frame types:

       CRITICAL: The OpenClaw Gateway uses raw WebSocket with a custom JSON-RPC protocol. Three frame types:
       - `{type: "req", id, method, params}` -- client-to-gateway request
       - `{type: "res", id, ok, payload?, error?}` -- gateway-to-client response
       - `{type: "event", event, payload}` -- gateway-to-client push event

       Define TypeScript types:
       ```typescript
       export type GatewayRequest = {
         type: 'req';
         id: string;
         method: string;
         params: unknown;
       };

       export type GatewayResponse = {
         type: 'res';
         id: string;
         ok: boolean;
         payload?: Record<string, unknown>;
         error?: { code: string; message: string };
       };

       export type GatewayEvent = {
         type: 'event';
         event: string;
         payload: Record<string, unknown>;
       };

       export type GatewayFrame = GatewayRequest | GatewayResponse | GatewayEvent;
       ```

       Also define known event types as a union for type safety where possible, but keep it extensible (unknown events should be handled gracefully).

    2. Create `src/entities/gateway-event/lib/parser.ts` with Zod schemas:
       - `GatewayFrameSchema` -- discriminated union on `type` field
       - `GatewayResponseSchema` -- validates response frames
       - `GatewayEventSchema` -- validates event frames
       - Each schema should use `.passthrough()` to allow unknown fields (the gateway may add fields we do not yet know about)
       - Export a `parseGatewayFrame(data: unknown): GatewayFrame` function that validates and returns typed frames, or throws with a descriptive error

    3. Create `src/entities/gateway-event/index.ts` barrel export:
       - Re-export all types from model/types.ts
       - Re-export parseGatewayFrame from lib/parser.ts

    4. Create `src/features/gateway-connection/model/types.ts`:
       ```typescript
       export type ConnectionState =
         | 'disconnected'
         | 'connecting'
         | 'authenticating'
         | 'connected'
         | 'reconnecting'
         | 'failed';

       export type ConnectionMode = 'local' | 'remote';

       export interface ConnectionConfig {
         url: string;
         token: string;
         mode: ConnectionMode;
         maxReconnectAttempts?: number;
         requestTimeout?: number;
       }
       ```

    5. Create `src/features/gateway-connection/lib/event-bus.ts` (per RESEARCH.md Pattern 3):
       - Typed event map with all known internal and gateway event topics
       - `on(event, handler): Unsubscribe` -- subscribe, returns cleanup function
       - `off(event, handler)` -- unsubscribe
       - `emit(event, payload)` -- dispatch to all handlers
       - `once(event, handler)` -- subscribe for single event
       - Wildcard support: `agent.*` matches `agent.status`, `agent.created`, etc.
       - Include internal events: `ws.state`, `ws.reconnecting`, `ws.failed`, `ws.connected`

       The EventMap type should be extensible. Use a base map with known events and allow string keys for unknown gateway events:
       ```typescript
       type KnownEvents = {
         'ws.state': { state: ConnectionState };
         'ws.reconnecting': { attempt: number; maxAttempts: number };
         'ws.failed': { reason: string; attempts: number };
         'ws.connected': { mode: ConnectionMode };
         'agent.status': { agentId: string; status: string };
         'chat.stream.start': { sessionId: string; messageId: string };
         'chat.stream.token': { sessionId: string; messageId: string; token: string };
         'chat.stream.end': { sessionId: string; messageId: string; fullText: string };
       };

       // Allow unknown gateway events with generic payload
       type EventMap = KnownEvents & Record<string, Record<string, unknown>>;
       ```

    6. Create `src/features/gateway-connection/lib/reconnect.ts`:
       - `ReconnectStrategy` class with configurable max attempts, base delay, max delay
       - Exponential backoff: `delay = min(baseDelay * 2^attempt + jitter, maxDelay)`
       - Jitter: random 0-1000ms added to prevent thundering herd
       - Methods: `nextDelay(): number`, `reset()`, `shouldRetry(): boolean`, `attempt: number`
       - Default: baseDelay 1000ms, maxDelay 30000ms, maxAttempts 5
  </action>
  <verify>
    - TypeScript compiles: `bunx tsc --noEmit` on all new files
    - Event Bus test: create a simple test file that subscribes, emits, and verifies handler is called
    - Zod parser test: pass valid and invalid frame JSON, verify correct parse/reject behavior
    - Reconnect strategy: verify delay increases exponentially and stops after max attempts
  </verify>
  <done>
    Gateway event type system defined with Zod validation. Event Bus supports typed subscriptions with wildcards. Reconnection strategy implements exponential backoff with jitter. Connection state machine types defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket Manager, Gateway Client, and dual-mode connection support</name>
  <files>
    src/features/gateway-connection/lib/ws-manager.ts
    src/features/gateway-connection/lib/gateway-client.ts
    src/features/gateway-connection/index.ts
  </files>
  <action>
    1. Create `src/features/gateway-connection/lib/ws-manager.ts` (per RESEARCH.md Pattern 1):

       **WebSocketManager class:**
       - Constructor takes EventBus instance and ConnectionConfig
       - Private state: `ws: WebSocket | null`, `state: ConnectionState`, `pendingRequests: Map<string, PendingRequest>`, `messageQueue: GatewayRequest[]`, `reconnectStrategy: ReconnectStrategy`
       - Uses `ws` library for Node.js (server-side) and native WebSocket for browser

       **connect(url, token) method:**
       - Sets state to 'connecting', creates WebSocket
       - onopen: sets state to 'authenticating' (wait for gateway challenge)
       - onmessage: parses frame with `parseGatewayFrame()`, handles three frame types:
         - `event` with `connect.challenge`: respond with connect request (role: 'operator', scopes, auth token, client info)
         - `event` (all others): dispatch to EventBus via `eventBus.emit(frame.event, frame.payload)`
         - `res`: match to pending request by ID. If `ok` and payload has `auth.deviceToken` (hello-ok), set state to 'connected' and flush message queue. Otherwise resolve/reject the pending promise.
       - onclose: if not clean close and state is not 'failed', schedule reconnect
       - onerror: log error, let onclose handle reconnection

       **request(method, params) method:**
       - Creates request frame with nanoid ID
       - If not connected, queues the request
       - Returns Promise that resolves when matching response arrives or rejects on timeout (default 30s)

       **disconnect() method:**
       - Set state to 'disconnected'
       - Close WebSocket with code 1000
       - Reject all pending requests
       - Clear message queue

       **retry() method:**
       - Reset reconnect strategy
       - Call connect() again
       - This is what the "Retry" button in the UI calls when state is 'failed'

       **Private helpers:**
       - `setState(state)`: update state, emit 'ws.state' event
       - `scheduleReconnect(url, token)`: check reconnect strategy, set 'reconnecting', emit 'ws.reconnecting', setTimeout for next attempt
       - `flushMessageQueue()`: send all queued requests after connection established
       - `sendRaw(frame)`: JSON.stringify and send

       IMPORTANT: The gateway sends `connect.challenge` event first. Client must NOT send anything before receiving it. This is the three-phase handshake documented in RESEARCH.md Pitfall 2.

    2. Create `src/features/gateway-connection/lib/gateway-client.ts` (per RESEARCH.md Pattern 2):

       **GatewayClient class:**
       - Constructor takes WebSocketManager
       - Clean async methods that abstract the raw protocol:

       ```typescript
       // Agent operations
       async getAgents(): Promise<Agent[]>
       async getAgent(agentId: string): Promise<Agent>

       // Health
       async getHealth(): Promise<GatewayHealth>

       // Chat
       async sendMessage(agentId: string, message: string, sessionId?: string): Promise<void>

       // Config (local mode only)
       async getConfig(): Promise<GatewayConfig>

       // Sessions
       async getSessions(agentId: string): Promise<Session[]>
       ```

       - Each method calls `this.ws.request(method, params)` and validates the response with a Zod schema before returning
       - Define internal domain types (Agent, GatewayHealth, etc.) that are AXion Hub's own types, NOT the gateway's raw types
       - Zod `.transform()` maps gateway field names to internal field names (e.g., `agent_id` -> `id`, `display_name` -> `name`)

       **Dual-mode support:**
       - Accept `ConnectionMode` in constructor or config
       - For methods that require filesystem access (reading config files, session JSONL files, memory SQLite):
         - In local mode: these will be implemented via separate filesystem API routes (future phases)
         - In remote mode: return a "not available in remote mode" result or throw a typed error
       - The GatewayClient itself only does WebSocket operations. Filesystem operations are separate.

       Create a helper type:
       ```typescript
       type ModeAwareResult<T> = { available: true; data: T } | { available: false; reason: 'remote-mode' };
       ```

    3. Create `src/features/gateway-connection/index.ts` barrel export:
       - Export WebSocketManager, EventBus, GatewayClient, ReconnectStrategy
       - Export all types from model/types.ts
       - Export a factory function `createGatewayStack(config: ConnectionConfig)` that:
         - Creates EventBus
         - Creates ReconnectStrategy
         - Creates WebSocketManager with both
         - Creates GatewayClient with the manager
         - Returns `{ eventBus, wsManager, gatewayClient }`

    IMPORTANT anti-patterns to avoid (per RESEARCH.md):
    - Do NOT use Socket.IO -- the gateway speaks raw WebSocket JSON-RPC
    - Do NOT import gateway protocol types in UI code -- everything goes through GatewayClient
    - Do NOT poll -- the gateway pushes events via WebSocket
  </action>
  <verify>
    - TypeScript compiles without errors
    - Unit tests for WebSocketManager: mock WebSocket, verify state transitions (disconnected -> connecting -> authenticating -> connected)
    - Unit tests for GatewayClient: mock ws.request(), verify Zod validation on response
    - Unit tests for reconnection: verify exponential backoff timing and max attempt cutoff
    - The index.ts barrel exports all expected symbols
  </verify>
  <done>
    WebSocket Manager handles the full OpenClaw Gateway protocol: three-phase handshake, request/response matching, event dispatch to Event Bus, and automatic reconnection with exponential backoff. Gateway Client provides clean typed methods that abstract the raw protocol. Dual-mode support allows graceful degradation in remote mode. All gateway data is Zod-validated before reaching feature code.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles all gateway connection files without errors
2. WebSocketManager state machine transitions correctly through all states
3. Event Bus delivers typed events to subscribers, including wildcards
4. GatewayClient methods validate responses with Zod schemas
5. Reconnection stops after max attempts and supports manual retry
6. Dual-mode detection correctly identifies local vs remote
7. No Socket.IO imports anywhere in the codebase
</verification>

<success_criteria>
- WebSocketManager connects, authenticates (three-phase handshake), sends/receives frames
- Event Bus dispatches typed events with wildcard support
- GatewayClient exposes clean async API that hides raw protocol details
- Reconnection uses exponential backoff with jitter, stops at max attempts
- All gateway responses validated through Zod before reaching feature code
- Dual-mode support: WebSocket-only in remote mode, filesystem operations flagged as unavailable
- Unit tests pass for core logic (state machine, event bus, reconnection timing)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md`
</output>
