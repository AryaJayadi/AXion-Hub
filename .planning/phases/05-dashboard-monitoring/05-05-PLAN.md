---
phase: 05-dashboard-monitoring
plan: 05
type: execute
wave: 4
depends_on: ["05-04"]
files_modified:
  - src/features/dashboard/model/alert-schema.ts
  - src/features/dashboard/lib/alert-templates.ts
  - src/features/dashboard/components/alert-rule-form.tsx
  - src/features/dashboard/components/alert-template-picker.tsx
  - src/features/dashboard/components/notification-bell.tsx
  - src/features/dashboard/api/use-alert-rules.ts
  - src/views/dashboard/monitor-alerts-view.tsx
  - app/(dashboard)/monitor/alerts/page.tsx
  - src/shared/lib/queue.ts
  - workers/alert-worker.ts
autonomous: true
requirements: [MNTR-04]

must_haves:
  truths:
    - "User can configure alert rules via template presets with customizable thresholds"
    - "User can view existing alert rules at /monitor/alerts"
    - "User can create new alert rules from template presets"
    - "Alert notifications appear in-app via bell icon and toasts"
    - "Each alert rule supports a webhook URL for external notifications"
    - "Alert evaluation runs server-side via BullMQ worker"
  artifacts:
    - path: "src/features/dashboard/model/alert-schema.ts"
      provides: "Drizzle schema for alert_rules and alert_notifications tables"
    - path: "src/features/dashboard/lib/alert-templates.ts"
      provides: "Static alert template preset definitions"
    - path: "src/features/dashboard/components/alert-rule-form.tsx"
      provides: "Alert rule creation/edit form"
    - path: "src/features/dashboard/components/alert-template-picker.tsx"
      provides: "Template selection for quick rule creation"
    - path: "src/features/dashboard/components/notification-bell.tsx"
      provides: "Bell icon with badge counter for header bar"
    - path: "src/views/dashboard/monitor-alerts-view.tsx"
      provides: "/monitor/alerts page composition"
    - path: "workers/alert-worker.ts"
      provides: "BullMQ worker for alert evaluation and webhook delivery"
    - path: "app/(dashboard)/monitor/alerts/page.tsx"
      provides: "Next.js route for /monitor/alerts"
  key_links:
    - from: "src/features/dashboard/components/alert-rule-form.tsx"
      to: "src/features/dashboard/lib/alert-templates.ts"
      via: "Template preset loading into form fields"
      pattern: "ALERT_TEMPLATES"
    - from: "workers/alert-worker.ts"
      to: "src/shared/lib/queue.ts"
      via: "BullMQ alertQueue consumption"
      pattern: "alertQueue"
    - from: "src/features/dashboard/components/notification-bell.tsx"
      to: "src/features/dashboard/model/alert-store.ts"
      via: "useAlertStore for unread count"
      pattern: "useAlertStore"
---

<objective>
Build the alert rules system: database schema for rules and notifications, template presets, rule management UI at /monitor/alerts, notification bell with badge counter, and BullMQ worker for server-side alert evaluation and webhook delivery.

Purpose: Deliver MNTR-04 (alert rules configuration and notification history). This gives users proactive alerting when things go wrong -- configurable via templates with in-app and webhook notifications.

Output: Alert schema (Drizzle), 6 template presets, rule form with template picker, notification bell, alert management page, BullMQ alert worker.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dashboard-monitoring/05-RESEARCH.md
@.planning/phases/05-dashboard-monitoring/05-01-SUMMARY.md
@src/shared/lib/queue.ts
@src/features/audit/model/schema.ts
@src/features/dashboard/model/alert-store.ts
@workers/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create alert DB schema, templates, BullMQ worker, and queue setup</name>
  <files>
    src/features/dashboard/model/alert-schema.ts
    src/features/dashboard/lib/alert-templates.ts
    src/shared/lib/queue.ts
    workers/alert-worker.ts
  </files>
  <action>
    1. Create `src/features/dashboard/model/alert-schema.ts`:
       - Import pgTable, varchar, integer, timestamp, boolean, jsonb, uuid from drizzle-orm/pg-core
       - Follow existing schema pattern from `src/features/audit/model/schema.ts`

       `alert_rules` table:
       - `id`: uuid, primaryKey, defaultRandom()
       - `name`: varchar(255), not null
       - `description`: varchar(1000)
       - `templateId`: varchar(100) -- nullable, references the template preset used to create it
       - `enabled`: boolean, default true, not null
       - `metric`: varchar(100), not null -- e.g., "agent.status", "error.rate", "agent.context_usage"
       - `operator`: varchar(10), not null -- ">", "<", "==", "!="
       - `threshold`: integer, not null
       - `duration`: integer, default 0, not null -- seconds, 0 means instant
       - `severity`: varchar(20), not null -- "critical", "warning", "info"
       - `webhookUrl`: varchar(2000) -- nullable, for external notification delivery
       - `createdAt`: timestamp, defaultNow(), not null
       - `updatedAt`: timestamp, defaultNow(), not null
       - Export types: `AlertRule` (InferSelectModel), `NewAlertRule` (InferInsertModel)

       `alert_notifications` table:
       - `id`: uuid, primaryKey, defaultRandom()
       - `ruleId`: uuid, not null -- references alert_rules.id
       - `severity`: varchar(20), not null
       - `message`: varchar(1000), not null
       - `details`: jsonb -- additional context
       - `read`: boolean, default false, not null
       - `webhookDelivered`: boolean -- null if no webhook, true/false for delivery status
       - `createdAt`: timestamp, defaultNow(), not null
       - Indexes on ruleId and createdAt for query performance

    2. Create `src/features/dashboard/lib/alert-templates.ts`:
       - Per locked decision: "Alert rules configured via template presets with customizable thresholds"
       - Define `AlertTemplate` interface: { id, name, description, icon (lucide icon name), condition: { metric, operator, threshold, duration }, severity }
       - Export `ALERT_TEMPLATES` array with 6 presets (from research):
         - "agent-down": Agent offline > 5 minutes (critical)
         - "high-error-rate": Error rate > 10% in 15 minutes (warning)
         - "context-window-full": Context usage > 90% (warning)
         - "gateway-disconnect": Gateway down > 1 minute (critical)
         - "cost-spike": Hourly cost > $5 (info)
         - "task-stuck": Task in-progress > 30 minutes (warning)

    3. Update `src/shared/lib/queue.ts`:
       - Add `alertQueue` export below the existing auditQueue:
         ```typescript
         export const alertQueue = new Queue("alerts", {
           connection: createBullMQConnection(),
           defaultJobOptions: {
             removeOnComplete: { count: 500 },
             removeOnFail: { count: 1000 },
             attempts: 3,
             backoff: { type: "exponential", delay: 2000 },
           },
         });
         ```
       - Remove the placeholder comment about notificationQueue (alertQueue serves that purpose)

    4. Create `workers/alert-worker.ts`:
       - Import `Worker, Job` from `bullmq`
       - Import `createRedisConnection` from `@/shared/lib/redis` (use the same path pattern as existing worker)
       - Import `db` from `@/shared/lib/db`
       - Import `alertNotifications` from alert schema

       Worker processes two job types:
       - `evaluate-rule`: Checks a rule condition against current state. For now, this is a skeleton that logs the evaluation (real evaluation needs gateway data from Phase 7+). Insert an alert_notification record if condition met.
       - `deliver-webhook`: Takes { webhookUrl, payload } and does a `fetch(webhookUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) })` with error handling (log failures, don't throw to avoid queue retry exhaustion for 4xx errors -- only retry on 5xx/network errors).

       Follow the existing worker pattern in `workers/index.ts` -- check how the audit worker is set up and mirror the structure.

       Per research: "Alert evaluation and webhook delivery MUST happen in BullMQ workers (background jobs). The existing infrastructure already has BullMQ + Redis set up."
  </action>
  <verify>
    Run `bun run build` -- zero TypeScript errors. Verify alert_rules and alert_notifications tables are defined. Verify alertQueue exists in queue.ts. Verify alert-worker.ts handles both job types. Run `npx drizzle-kit generate` to verify schema is valid (or just confirm build passes).
  </verify>
  <done>
    Alert rules and notifications Drizzle schema created with proper columns and indexes. 6 alert template presets defined. BullMQ alertQueue added to shared queue module. Alert worker handles rule evaluation and webhook delivery with proper error handling. Database migration ready to generate.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build alert rule management UI, notification bell, and /monitor/alerts page</name>
  <files>
    src/features/dashboard/components/alert-rule-form.tsx
    src/features/dashboard/components/alert-template-picker.tsx
    src/features/dashboard/components/notification-bell.tsx
    src/features/dashboard/api/use-alert-rules.ts
    src/views/dashboard/monitor-alerts-view.tsx
    app/(dashboard)/monitor/alerts/page.tsx
  </files>
  <action>
    1. Create `src/features/dashboard/api/use-alert-rules.ts`:
       - TanStack Query hooks for alert rule CRUD:
         - `useAlertRules()`: fetches all rules, uses `queryKeys.alerts.rules()`, mock data (return 3 pre-configured rules matching templates), staleTime: 30 seconds
         - `useCreateAlertRule()`: mutation that would POST to API (mock: add to query cache optimistically, show success toast via sonner)
         - `useUpdateAlertRule()`: mutation for toggling enabled/disabled and editing
         - `useDeleteAlertRule()`: mutation with confirmation (mock: remove from cache, show toast)
       - Follow the mutation pattern from `src/features/agents/api/use-agent-mutations.ts`

    2. Create `src/features/dashboard/components/alert-template-picker.tsx`:
       - "use client" component
       - Import `ALERT_TEMPLATES` from `../lib/alert-templates`
       - Props: `onSelect: (template: AlertTemplate) => void`
       - Render a grid of template cards (2-3 columns)
       - Each card shows: icon (mapped from lucide-react), name, description, severity badge, default threshold
       - Clicking a card calls `onSelect(template)` to populate the rule form
       - Use Card component for each template

    3. Create `src/features/dashboard/components/alert-rule-form.tsx`:
       - "use client" component
       - Per locked decision: "Alert rules configured via template presets with customizable thresholds"
       - Per locked decision: "Alert notifications: in-app (bell icon, toasts) plus webhook URL per rule"
       - Import react-hook-form with zodResolver
       - Zod schema for alert rule: name (required), description, metric, operator, threshold (number, min 0), duration (number, min 0), severity (enum), webhookUrl (optional, url format when provided), enabled (boolean)
       - Props: `initialValues?: Partial<AlertRule>`, `onSubmit: (data) => void`, `onCancel: () => void`
       - Form fields:
         - Name (text input, required)
         - Description (textarea)
         - Metric (select: agent.status, error.rate, agent.context_usage, gateway.status, cost.hourly, task.duration)
         - Operator (select: >, <, ==, !=)
         - Threshold (number input)
         - Duration (number input, in seconds, with helper text "0 for instant alerts")
         - Severity (select: critical, warning, info)
         - Webhook URL (text input, optional, with helper text "Sends JSON POST to this URL on alert")
         - Enabled (switch toggle)
       - Use zodResolver with as-any cast (same pattern as wizard steps in Phase 3 per decision [03-03])
       - Submit and Cancel buttons at bottom
       - Use FormField wrapper from `@/shared/ui/form-field` for consistent label/error styling

    4. Create `src/features/dashboard/components/notification-bell.tsx`:
       - "use client" component
       - Per locked decision: "Alert notifications: in-app (bell icon, toasts)"
       - Import `Bell` from lucide-react
       - Import `useAlertStore` from `@/features/dashboard`
       - Import `Button` from `@/shared/ui/button`
       - Import `Popover, PopoverTrigger, PopoverContent` from `@/shared/ui/popover`
       - Render a Bell icon button with a badge counter overlay showing `unreadAlertCount`
       - Badge: absolute positioned, small red circle with count (hide when 0)
       - On click: open a popover showing recent alerts (max 10) from `useAlertStore(s => s.recentAlerts)`
       - Each alert shows: severity icon, rule name, message, relative timestamp
       - "Mark all read" button at bottom of popover -- calls `useAlertStore.getState().markAllRead()`
       - This component is designed to be placed in the HeaderBar (integration deferred to avoid modifying app-shell in this plan -- add a TODO comment noting it should be added to HeaderBar)

    5. Create `src/views/dashboard/monitor-alerts-view.tsx`:
       - "use client" component
       - Import `PageHeader` from `@/shared/ui/page-header`
       - Import `AlertTemplatePicker`, `AlertRuleForm` from dashboard feature components
       - Import `useAlertRules`, `useCreateAlertRule`, `useDeleteAlertRule` hooks
       - Import `Dialog, DialogContent, DialogTrigger` from `@/shared/ui/dialog`
       - Import `DataTable` from `@/shared/ui/data-table`
       - Import `Switch` from `@/shared/ui/switch`

       Page layout:
       - PageHeader: "Alert Rules" with description "Configure alert rules and notification preferences"
       - "Create Rule" button in PageHeader actions -- opens a Dialog with two steps:
         a. AlertTemplatePicker (select a template to pre-fill)
         b. AlertRuleForm (with template values pre-loaded, all editable)
         c. User can also skip templates and fill the form from scratch
       - Below: DataTable of existing rules with columns:
         - Name, Metric, Threshold, Severity badge, Enabled (Switch toggle), Webhook (truncated URL or "None"), Actions (edit/delete dropdown)
       - Toggle the Switch inline to enable/disable a rule via useUpdateAlertRule mutation
       - Delete action shows confirmation dialog

    6. Create `app/(dashboard)/monitor/alerts/page.tsx`:
       - Import and render `MonitorAlertsView`
       - Export metadata: `{ title: "Alert Rules | AXion Hub" }`
  </action>
  <verify>
    Run `bun run build` -- zero errors. Verify /monitor/alerts route exists. Verify AlertTemplatePicker renders 6 templates. Verify AlertRuleForm uses react-hook-form with zodResolver. Verify NotificationBell reads from alert store.
  </verify>
  <done>
    /monitor/alerts page renders a DataTable of alert rules with inline toggle switches, create/edit/delete functionality, and template-based rule creation. Notification bell component shows unread count with popover for recent alerts. Alert rule form validates with Zod and supports webhook URL configuration. The full alert management experience is functional with mock data.
  </done>
</task>

</tasks>

<verification>
1. `bun run build` passes with zero errors
2. Drizzle schema for alert_rules and alert_notifications tables is valid
3. alertQueue added to shared queue module
4. Alert worker processes evaluate-rule and deliver-webhook jobs
5. /monitor/alerts renders DataTable of rules with template picker and form
6. NotificationBell shows unread count from alert store
7. 6 alert template presets available in template picker
8. Alert rule form validates with Zod (name required, threshold >= 0, etc.)
</verification>

<success_criteria>
- Alert rules Drizzle schema has correct columns and indexes for both tables
- 6 template presets match research specification (agent-down, high-error-rate, context-window-full, gateway-disconnect, cost-spike, task-stuck)
- Alert rule form validates all fields with Zod, pre-populates from templates
- Notification bell shows badge counter and popover with recent alerts
- BullMQ alert worker handles rule evaluation and webhook delivery
- /monitor/alerts page has DataTable with inline enable/disable switches
- `bun run build` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-monitoring/05-05-SUMMARY.md`
</output>
