---
phase: 05-dashboard-monitoring
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/providers/gateway-provider.tsx
autonomous: true
gap_closure: true
requirements:
  - DASH-06
  - MNTR-01

must_haves:
  truths:
    - "WebSocket events from EventBus flow into the dashboard store (agent counts, cost, stale flag)"
    - "WebSocket events from EventBus flow into the activity store (events buffer populates)"
    - "WebSocket agent.status events update the agent store (agent status changes in real time)"
  artifacts:
    - path: "src/app/providers/gateway-provider.tsx"
      provides: "Store subscription wiring for dashboard, activity, and agent stores"
      contains: "initDashboardStoreSubscriptions"
  key_links:
    - from: "src/app/providers/gateway-provider.tsx"
      to: "src/features/dashboard/model/dashboard-store.ts"
      via: "initDashboardStoreSubscriptions(eventBus)"
      pattern: "initDashboardStoreSubscriptions\\(eventBus\\)"
    - from: "src/app/providers/gateway-provider.tsx"
      to: "src/features/dashboard/model/activity-store.ts"
      via: "initActivityStoreSubscriptions(eventBus)"
      pattern: "initActivityStoreSubscriptions\\(eventBus\\)"
    - from: "src/app/providers/gateway-provider.tsx"
      to: "src/features/agents/model/agent-store.ts"
      via: "initAgentStoreSubscriptions(eventBus)"
      pattern: "initAgentStoreSubscriptions\\(eventBus\\)"
---

<objective>
Wire dashboard, activity, and agent store subscriptions in GatewayProvider so WebSocket events flow into Zustand stores at runtime.

Purpose: Close the single blocker preventing real-time data from reaching the dashboard and activity feed. All three init functions are fully implemented and exported but never called — the GatewayProvider was not updated as new features were added in Phases 3 and 5.

Output: Updated gateway-provider.tsx with all store subscriptions initialized alongside the existing initConnectionStoreSubscriptions call, with proper cleanup.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dashboard-monitoring/05-VERIFICATION.md

@src/app/providers/gateway-provider.tsx
@src/features/dashboard/index.ts
@src/features/agents/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire all store subscriptions in GatewayProvider</name>
  <files>src/app/providers/gateway-provider.tsx</files>
  <action>
Add imports for the three missing init functions and call them inside the existing useEffect, following the exact same pattern as the existing `initConnectionStoreSubscriptions` call.

1. Add two new imports at the top of the file:
   - `import { initDashboardStoreSubscriptions, initActivityStoreSubscriptions } from "@/features/dashboard";`
   - `import { initAgentStoreSubscriptions } from "@/features/agents";`

2. Inside the existing `useEffect` callback, after `const cleanup = initConnectionStoreSubscriptions(eventBus);`, add:
   ```typescript
   const cleanupDashboard = initDashboardStoreSubscriptions(eventBus);
   const cleanupActivity = initActivityStoreSubscriptions(eventBus);
   const cleanupAgents = initAgentStoreSubscriptions(eventBus);
   ```

3. Update the cleanup return function to call all four cleanup functions:
   ```typescript
   return () => {
     cleanup();
     cleanupDashboard();
     cleanupActivity();
     cleanupAgents();
     wsManager.disconnect();
   };
   ```

4. Add `cleanupDashboard` and `cleanupActivity` and `cleanupAgents` variables — all three init functions return `() => void` cleanup functions (already verified in source).

Note on initAgentStoreSubscriptions: This function (from Phase 3) does NOT currently return a cleanup function — it returns `void`. Either:
  - Wrap the call: `const cleanupAgents = initAgentStoreSubscriptions(eventBus) ?? (() => {});`
  - Or call it without capturing: `initAgentStoreSubscriptions(eventBus);` and omit from cleanup.

  Check the actual return type and handle accordingly. The dashboard and activity inits DO return cleanup functions.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no type errors in gateway-provider.tsx
2. Grep for all three init calls in gateway-provider.tsx: `grep -c 'init.*StoreSubscriptions' src/app/providers/gateway-provider.tsx` should return 4 (connection + dashboard + activity + agents)
3. Run `npm run build` or `npx next build` — build succeeds
  </verify>
  <done>
gateway-provider.tsx imports and calls initDashboardStoreSubscriptions, initActivityStoreSubscriptions, and initAgentStoreSubscriptions alongside the existing initConnectionStoreSubscriptions, with cleanup functions properly returned. All four store subscription pipelines are wired to the EventBus at app startup.
  </done>
</task>

</tasks>

<verification>
1. `grep 'initDashboardStoreSubscriptions' src/app/providers/gateway-provider.tsx` — matches import and call
2. `grep 'initActivityStoreSubscriptions' src/app/providers/gateway-provider.tsx` — matches import and call
3. `grep 'initAgentStoreSubscriptions' src/app/providers/gateway-provider.tsx` — matches import and call
4. TypeScript compiles without errors
5. The cleanup function in useEffect calls all subscription cleanup functions before wsManager.disconnect()
</verification>

<success_criteria>
- gateway-provider.tsx calls all four init*StoreSubscriptions functions in its useEffect
- All cleanup functions are called in the useEffect return
- TypeScript builds without errors
- DASH-06 and MNTR-01 gaps are closed (real-time EventBus → store pipeline is active)
- Phase 3 initAgentStoreSubscriptions gap is also closed (same systemic pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-monitoring/05-06-SUMMARY.md`
</output>
