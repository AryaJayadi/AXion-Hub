---
phase: 05-dashboard-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bun.lock
  - src/entities/dashboard-event/model/types.ts
  - src/entities/dashboard-event/lib/parser.ts
  - src/entities/dashboard-event/index.ts
  - src/features/dashboard/model/dashboard-store.ts
  - src/features/dashboard/model/activity-store.ts
  - src/features/dashboard/model/alert-store.ts
  - src/features/dashboard/lib/cost-formatter.ts
  - src/features/dashboard/lib/event-mapper.ts
  - src/features/dashboard/index.ts
  - src/shared/lib/query-keys.ts
  - src/widgets/dashboard-grid/components/bento-grid.tsx
autonomous: true
requirements: [DASH-01, DASH-02, DASH-03, DASH-04, DASH-05, DASH-06]

must_haves:
  truths:
    - "Dashboard stores exist and can hold agent counts, task summary, cost data, and activity events"
    - "Activity store maintains a circular buffer of the last 20 events"
    - "Query keys exist for dashboard, activity, and alert domains"
    - "Bento grid renders a responsive CSS Grid that collapses to single column on mobile"
  artifacts:
    - path: "src/entities/dashboard-event/model/types.ts"
      provides: "DashboardEvent, EventFilter, CostSummary, TaskSummary types"
    - path: "src/features/dashboard/model/dashboard-store.ts"
      provides: "Dashboard Zustand store with agent counts, task summary, cost data"
      exports: ["useDashboardStore", "initDashboardStoreSubscriptions"]
    - path: "src/features/dashboard/model/activity-store.ts"
      provides: "Activity Zustand store with circular buffer"
      exports: ["useActivityStore", "initActivityStoreSubscriptions"]
    - path: "src/features/dashboard/model/alert-store.ts"
      provides: "Alert notification Zustand store"
      exports: ["useAlertStore"]
    - path: "src/widgets/dashboard-grid/components/bento-grid.tsx"
      provides: "BentoGrid and BentoGridItem layout components"
    - path: "src/shared/lib/query-keys.ts"
      provides: "dashboard, activity, alerts query key factories"
      contains: "dashboard:"
  key_links:
    - from: "src/features/dashboard/model/dashboard-store.ts"
      to: "src/features/gateway-connection/lib/event-bus.ts"
      via: "EventBus subscriptions in initDashboardStoreSubscriptions"
      pattern: "eventBus\\.on"
    - from: "src/features/dashboard/model/activity-store.ts"
      to: "src/features/gateway-connection/lib/event-bus.ts"
      via: "EventBus namespace wildcard subscriptions"
      pattern: "eventBus\\.on"
---

<objective>
Install Phase 5 dependencies, create the dashboard-event entity with types, build the three Zustand stores (dashboard, activity, alert), extend query keys, create cost formatting utilities, and build the reusable BentoGrid layout widget.

Purpose: Establish the shared data layer and layout foundation that all dashboard widgets, activity pages, and monitor pages will consume. Without these stores, hooks, and types, no dashboard widget can render real-time data.

Output: Dashboard-event entity, three Zustand stores wired to EventBus, extended query keys, cost formatter, event mapper, and BentoGrid widget component.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dashboard-monitoring/05-RESEARCH.md
@src/features/gateway-connection/index.ts
@src/features/agents/model/agent-store.ts
@src/entities/agent/model/types.ts
@src/shared/lib/query-keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create dashboard-event entity with types and utilities</name>
  <files>
    package.json
    bun.lock
    src/entities/dashboard-event/model/types.ts
    src/entities/dashboard-event/lib/parser.ts
    src/entities/dashboard-event/index.ts
    src/features/dashboard/lib/cost-formatter.ts
    src/features/dashboard/lib/event-mapper.ts
  </files>
  <action>
    1. Install Phase 5 dependencies:
       ```bash
       bun add @number-flow/react @xyflow/react @dagrejs/dagre
       ```

    2. Create `src/entities/dashboard-event/model/types.ts` with these types:
       - `DashboardEvent`: { id: string, timestamp: Date, type: string, source: string, agentId?: string, summary: string, details?: unknown, severity: 'info' | 'warning' | 'error' }
       - `EventFilter`: { types?: string[], sources?: string[], agentId?: string, severity?: string[], search?: string, dateRange?: { from: Date, to: Date } }
       - `CostSummary`: { tokens: number, dollars: number, inputTokens: number, outputTokens: number }
       - `TaskSummary`: Record<string, number> (keys: inbox, assigned, inProgress, review, done)
       - `AgentCostData`: { agentId: string, agentName: string, model: string, inputTokens: number, outputTokens: number, cost: number }
       - `TimePeriod`: 'session' | 'today' | 'week'
       - `ServiceHealth`: { id: string, name: string, type: 'gateway' | 'provider' | 'channel' | 'node', health: 'healthy' | 'degraded' | 'down', metrics?: { uptime: number, latency: number, errorRate: number }, connectedTo: string[] }

    3. Create `src/entities/dashboard-event/lib/parser.ts`:
       - `parseGatewayEvent(eventType: string, payload: unknown): DashboardEvent` -- maps raw EventBus events into DashboardEvent objects. Generate a nanoid for `id`, use current Date for `timestamp`, extract agentId from payload if present, derive a human-readable `summary` based on event type (e.g., "agent.status" -> "Agent {name} changed to {status}"). Derive severity from event type (error events -> 'error', status changes -> 'info', etc.).

    4. Create `src/entities/dashboard-event/index.ts` barrel export re-exporting all types and the parser.

    5. Create `src/features/dashboard/lib/cost-formatter.ts`:
       - `formatTokenCount(tokens: number): string` -- formats with K/M suffixes (e.g., 1500 -> "1.5K", 1200000 -> "1.2M")
       - `formatDollarCost(dollars: number): string` -- formats to 2 decimal places with $ prefix (e.g., 0.0523 -> "$0.05", 12.456 -> "$12.46")
       - `estimateCost(inputTokens: number, outputTokens: number, model: string): number` -- returns estimated dollar cost based on model pricing. Use approximate per-token rates for claude-sonnet-4 ($3/1M input, $15/1M output) as default.

    6. Create `src/features/dashboard/lib/event-mapper.ts`:
       - `EVENT_NAMESPACES`: string array of EventBus namespaces to subscribe to: ["agent.*", "chat.*", "exec.*", "ws.*"]
       - `getEventDisplayInfo(type: string): { icon: string, color: string, label: string }` -- maps event type prefixes to display metadata (e.g., "agent.*" -> { icon: "Bot", color: "blue", label: "Agent" }, "chat.*" -> { icon: "MessageSquare", color: "green", label: "Chat" }, "ws.*" -> { icon: "Wifi", color: "purple", label: "System" }, "exec.*" -> { icon: "Cog", color: "orange", label: "Execution" }).
  </action>
  <verify>
    Run `bun run build` and confirm no TypeScript errors. Verify @number-flow/react, @xyflow/react, @dagrejs/dagre appear in package.json dependencies. Verify all type exports resolve: `grep -r "DashboardEvent" src/entities/dashboard-event/`.
  </verify>
  <done>
    @number-flow/react, @xyflow/react, and @dagrejs/dagre are installed. DashboardEvent entity with types, parser, cost formatter, and event mapper exist and build cleanly. All types are importable from @/entities/dashboard-event.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zustand stores, extend query keys, and build BentoGrid widget</name>
  <files>
    src/features/dashboard/model/dashboard-store.ts
    src/features/dashboard/model/activity-store.ts
    src/features/dashboard/model/alert-store.ts
    src/features/dashboard/index.ts
    src/shared/lib/query-keys.ts
    src/widgets/dashboard-grid/components/bento-grid.tsx
  </files>
  <action>
    1. Create `src/features/dashboard/model/dashboard-store.ts`:
       - Zustand store with interface:
         - `agentCounts`: Record<AgentStatus, number> (online, idle, working, error, offline) -- default all 0
         - `totalAgents`: number
         - `taskSummary`: TaskSummary (default all 0, mock data until Phase 6)
         - `costByPeriod`: Record<TimePeriod, CostSummary> (session/today/week, default all 0)
         - `perAgentCosts`: AgentCostData[]
         - `isStale`: boolean (set to true on gateway disconnect, false on reconnect)
         - Actions: `updateAgentCounts`, `updateTaskSummary`, `updateCosts`, `updatePerAgentCosts`, `setStale`
       - Export `initDashboardStoreSubscriptions(eventBus: EventBus): () => void`:
         - Subscribe to `agent.status` events -- recalculate agentCounts from the agent store (import useAgentStore)
         - Subscribe to `ws.disconnected` -- set isStale: true
         - Subscribe to `ws.connected` -- set isStale: false
         - Return cleanup function that unsubscribes all listeners
       - Follow the existing pattern from `src/features/agents/model/agent-store.ts`

    2. Create `src/features/dashboard/model/activity-store.ts`:
       - Zustand store with:
         - `events`: DashboardEvent[] (max 20 for dashboard, acts as circular buffer)
         - `fullEvents`: DashboardEvent[] (max 200 for /activity page)
         - `unreadCount`: number
         - Actions: `pushEvent(event: DashboardEvent)` -- prepend to both arrays, trim to max sizes, increment unreadCount
         - `markRead()` -- reset unreadCount to 0
         - `clear()` -- empty both arrays
       - Export `initActivityStoreSubscriptions(eventBus: EventBus): () => void`:
         - Subscribe to each namespace in EVENT_NAMESPACES (from event-mapper.ts)
         - For each event, run `parseGatewayEvent()` then `pushEvent()`
         - Return cleanup function

    3. Create `src/features/dashboard/model/alert-store.ts`:
       - Zustand store with:
         - `unreadAlertCount`: number
         - `recentAlerts`: Array<{ id: string, ruleId: string, ruleName: string, severity: 'critical' | 'warning' | 'info', message: string, timestamp: Date, read: boolean }>
         - Actions: `addAlert`, `markAllRead`, `markRead(id)`
       - No EventBus subscription yet (wired in plan 05-05 with BullMQ)

    4. Create `src/features/dashboard/index.ts` barrel export:
       - Re-export stores: useDashboardStore, useActivityStore, useAlertStore
       - Re-export init functions: initDashboardStoreSubscriptions, initActivityStoreSubscriptions
       - Re-export lib: cost-formatter functions, event-mapper functions, EVENT_NAMESPACES

    5. Extend `src/shared/lib/query-keys.ts`:
       - Add `dashboard` domain: all, stats(), costs(period: string), perAgentCosts()
       - Add `activity` domain: all, lists(), list(filters?), detail(id)
       - Add `alerts` domain: all, rules(), rule(id), notifications(), notificationList(filters?)

    6. Create `src/widgets/dashboard-grid/components/bento-grid.tsx`:
       - `BentoGrid` component: renders a CSS Grid container with Tailwind classes:
         - `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 auto-rows-[minmax(180px,auto)]`
         - Accepts `children` and optional `className`
       - `BentoGridItem` component: a Card wrapper accepting `className` for custom grid spans.
         - Props: `className`, `title`, `description`, `icon` (LucideIcon), `children`, `isStale?: boolean`
         - When `isStale` is true, add a subtle overlay/opacity indicator (opacity-60 + dashed border)
         - Use shadcn Card, CardHeader, CardTitle, CardDescription, CardContent
       - Per locked decision: "Bento grid collapses to a single vertical column on smaller screens"
       - Per locked decision: "Activity feed is the most visually prominent widget, takes the largest grid area" -- this is handled by the caller passing col-span/row-span classes
  </action>
  <verify>
    Run `bun run build` and confirm no TypeScript errors. Verify stores are importable: `grep -r "useDashboardStore\|useActivityStore\|useAlertStore" src/features/dashboard/`. Verify query-keys.ts has dashboard, activity, alerts entries. Verify BentoGrid component file exists.
  </verify>
  <done>
    Three Zustand stores (dashboard, activity, alert) exist with EventBus subscription initializers. Query keys extended with dashboard, activity, and alerts domains. BentoGrid widget renders a responsive CSS Grid with stale-data indicator support. All artifacts build cleanly and are importable from their barrel exports.
  </done>
</task>

</tasks>

<verification>
1. `bun run build` passes with zero errors
2. @number-flow/react, @xyflow/react, @dagrejs/dagre in package.json dependencies
3. DashboardEvent types importable from @/entities/dashboard-event
4. Three stores importable from @/features/dashboard
5. query-keys.ts has dashboard, activity, alerts entries
6. BentoGrid renders via import from @/widgets/dashboard-grid/components/bento-grid
</verification>

<success_criteria>
- All Phase 5 dependencies installed (3 packages)
- Dashboard-event entity has types, parser, and barrel export
- Dashboard, activity, and alert Zustand stores created with correct shapes
- Dashboard and activity stores have EventBus subscription initializer functions
- Query key factory extended for dashboard, activity, and alerts domains
- Cost formatter and event mapper utilities exist
- BentoGrid widget component renders responsive CSS Grid
- `bun run build` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-monitoring/05-01-SUMMARY.md`
</output>
