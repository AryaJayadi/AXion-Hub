---
phase: 08-sessions-memory-files-governance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/entities/memory/model/types.ts
  - src/entities/memory/index.ts
  - src/features/memory/api/use-memory-browser.ts
  - src/features/memory/api/use-memory-search.ts
  - src/features/memory/components/memory-agent-group.tsx
  - src/features/memory/components/memory-type-list.tsx
  - src/features/memory/components/memory-preview.tsx
  - src/features/memory/components/memory-search-results.tsx
  - src/features/memory/components/memory-search-card.tsx
  - src/views/memory/memory-browser-view.tsx
  - src/views/memory/memory-search-view.tsx
  - app/(dashboard)/memory/page.tsx
  - app/(dashboard)/memory/search/page.tsx
autonomous: true
requirements:
  - MEMO-01
  - MEMO-02

must_haves:
  truths:
    - "User can browse memories organized by agent first, then by memory type at /memory"
    - "Memories are read-only in the browser -- no edit or delete actions"
    - "User can perform semantic search across all agent memories at /memory/search"
    - "Search works cross-agent by default with optional agent filter"
    - "Search results display as card grid with surrounding context, agent name, and relevance"
  artifacts:
    - path: "src/entities/memory/model/types.ts"
      provides: "MemoryEntry, MemorySearchResult, AgentMemoryGroup types"
      contains: "MemorySearchResult"
    - path: "src/features/memory/components/memory-agent-group.tsx"
      provides: "Collapsible agent section with memory types"
      contains: "MemoryAgentGroup"
    - path: "src/features/memory/components/memory-search-results.tsx"
      provides: "Card grid search results"
      contains: "MemorySearchResults"
    - path: "src/views/memory/memory-browser-view.tsx"
      provides: "Memory browser page composition"
      contains: "MemoryBrowserView"
  key_links:
    - from: "app/(dashboard)/memory/page.tsx"
      to: "src/views/memory/memory-browser-view.tsx"
      via: "Next.js route -> view component"
      pattern: "MemoryBrowserView"
    - from: "src/views/memory/memory-search-view.tsx"
      to: "src/features/memory/api/use-memory-search.ts"
      via: "TanStack Query hook"
      pattern: "useMemorySearch"
---

<objective>
Build the cross-agent memory browser and semantic search experience: an agent-first memory browser with collapsible sections organized by memory type, and a search page with cross-agent fuzzy text matching displayed as a relevance-scored card grid.

Purpose: Users need to understand what their agents remember across all agents -- browsing through persistent, daily, and conversation memories, and searching across all memories to find specific knowledge.

Output: Memory entity types, 2 TanStack Query hooks with mock data, 5 feature components, 2 view compositions, 2 route pages.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/features/agents/components/agent-memory-browser.tsx (existing per-agent memory browser pattern to extend)
@src/shared/ui/data-table.tsx
@src/shared/ui/search-input.tsx (SearchInput with debounce)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Memory entity types, browser hook, and agent-first memory browser at /memory</name>
  <files>
    src/entities/memory/model/types.ts
    src/entities/memory/index.ts
    src/features/memory/api/use-memory-browser.ts
    src/features/memory/components/memory-agent-group.tsx
    src/features/memory/components/memory-type-list.tsx
    src/features/memory/components/memory-preview.tsx
    src/views/memory/memory-browser-view.tsx
    app/(dashboard)/memory/page.tsx
  </files>
  <action>
    **Entity types** (src/entities/memory/model/types.ts):
    - Define MemoryType: "persistent" | "daily" | "conversation"
    - Define MemoryEntry: { id (string), agentId (string), agentName (string), memoryType (MemoryType), filePath (string), fileName (string), content (string), lastModified (Date), size (number) }
    - Define AgentMemoryGroup: { agentId (string), agentName (string), agentAvatar (string | undefined), memories: MemoryEntry[] }
    - Define MemorySearchResult: { id (string), agentId (string), agentName (string), memoryType (MemoryType), filePath (string), snippet (string), beforeContext (string), afterContext (string), relevanceScore (number 0-1), lastModified (Date) }
    - All optional props use `| undefined` (exactOptionalPropertyTypes)
    - Barrel export from index.ts

    **use-memory-browser.ts**: TanStack Query hook returning AgentMemoryGroup[]. Generate mock data for 4 agents, each with:
    - 1 persistent memory (MEMORY.md -- longer content, 500-1000 chars of markdown with headers and bullet points)
    - 2-3 daily memories (2025-02-17.md, 2025-02-18.md -- shorter daily log entries)
    - 1-2 conversation memories (conv-abc123.md -- conversation summary snippets)
    Group by agent. staleTime: Infinity. Use queryKeys.memory.browser().

    **memory-agent-group.tsx**: MemoryAgentGroup component.
    - Takes AgentMemoryGroup as prop.
    - Renders as shadcn Collapsible, defaultOpen for first agent.
    - Trigger: agent name + avatar + badge showing memory count.
    - Content: MemoryTypeList for each memory type that has entries.

    **memory-type-list.tsx**: MemoryTypeList component.
    - Takes memoryType (string label) and MemoryEntry[] as props.
    - Renders section header (e.g., "Persistent Memory", "Daily Memory", "Conversation Memory") with a count badge.
    - List of clickable memory file entries: file name, last modified (date-fns formatDistanceToNow), size.
    - Clicking a file shows its content in MemoryPreview (controlled by parent state).

    **memory-preview.tsx**: MemoryPreview component.
    - Takes MemoryEntry (or null) as prop.
    - When null: show placeholder "Select a memory file to preview".
    - When set: render content as read-only markdown using @uiw/react-md-editor in preview mode (import via next/dynamic with ssr: false, same pattern as AgentIdentityEditor).
    - Header showing file path, agent name, memory type badge, last modified.
    - NO edit or delete buttons -- memories are read-only per user decision.

    **memory-browser-view.tsx**: MemoryBrowserView composition.
    - Uses useMemoryBrowser() for data.
    - Split layout: left sidebar (w-72 flex-shrink-0) with agent groups, right content area with MemoryPreview.
    - React state for selectedMemory (MemoryEntry | null).
    - Clicking a file in any agent group sets selectedMemory and shows preview.
    - PageHeader: "Memory Browser" with description "Browse all agent memories" and a "Search memories" button/link navigating to /memory/search.
    - Loading skeleton: left sidebar uses SkeletonList, right area uses SkeletonDetail.

    **Route page**: Standard async server component, Suspense wrapper.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - /memory renders agent-grouped memory browser
    - Clicking agent expands to show memory types
    - Clicking a file shows read-only markdown preview
    - No edit/delete buttons visible anywhere
  </verify>
  <done>
    - /memory shows agent-first memory browser with collapsible sections
    - Each agent section contains persistent, daily, and conversation memory types
    - Clicking a memory file shows read-only markdown preview
    - No editing capabilities present (read-only per user decision)
  </done>
</task>

<task type="auto">
  <name>Task 2: Semantic memory search with cross-agent card grid at /memory/search</name>
  <files>
    src/features/memory/api/use-memory-search.ts
    src/features/memory/components/memory-search-results.tsx
    src/features/memory/components/memory-search-card.tsx
    src/views/memory/memory-search-view.tsx
    app/(dashboard)/memory/search/page.tsx
  </files>
  <action>
    **use-memory-search.ts**: TanStack Query hook taking { query: string, agentId?: string }. Returns MemorySearchResult[].
    - Mock implementation: client-side fuzzy text search across all mock memory entries (same data source as browser hook). For each memory entry, check if query appears in content (case-insensitive). Extract snippet (100 chars around match), beforeContext (50 chars before), afterContext (50 chars after). Calculate relevanceScore based on match position (earlier = higher) and frequency (more matches = higher), normalized to 0-1.
    - If agentId provided, filter to that agent's memories only.
    - Sort results by relevanceScore descending.
    - enabled: query.length >= 2 (don't search on empty/single char).
    - Use queryKeys.memory.search(query, agentId).

    **memory-search-card.tsx**: MemorySearchCard component.
    - Takes MemorySearchResult as prop.
    - Card layout:
      - Top: agent name badge (colored by agent) + memory type badge + relevance indicator (filled dots or progress bar, e.g., 3/5 dots filled)
      - Middle: snippet with matched text highlighted (wrap match in `<mark>` tag or use bg-yellow-200/bg-yellow-900 for light/dark)
      - Bottom row: file path (text-muted-foreground, font-mono text-xs), last modified (date-fns formatDistanceToNow)
    - Context: show beforeContext...{snippet}...afterContext with ellipsis for surrounding context
    - Click navigates to /memory (or could scroll to that file -- for v1 just navigate to /memory)

    **memory-search-results.tsx**: MemorySearchResults component.
    - Takes MemorySearchResult[] as prop.
    - Responsive card grid: 1 col on mobile, 2 cols on md, 3 cols on lg.
    - Each card rendered via MemorySearchCard.
    - Empty state when no results: EmptyState with "No memories found" and suggestion to try different keywords.
    - Result count shown above grid: "X results across Y agents".

    **memory-search-view.tsx**: MemorySearchView composition.
    - SearchInput at top with debounce (use SearchInput component from src/shared/ui/search-input.tsx).
    - Optional agent filter: Select dropdown with "All agents" default + individual agent options. Use nuqs useQueryState for both `q` (search query) and `agent` (agent filter) URL params.
    - Below search: MemorySearchResults with the results from useMemorySearch.
    - Loading state: show loading spinner or skeleton cards while search is in flight.
    - Initial state (no query): show a prompt message "Search across all agent memories" with a search icon illustration.
    - PageHeader: "Memory Search" with breadcrumb Memory > Search and a "Browse memories" link back to /memory.

    **Route page**: Standard async server component, Suspense wrapper.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - /memory/search renders search input with agent filter
    - Typing a query shows matching memory cards with highlighted snippets
    - Agent filter narrows results to selected agent
    - Empty query shows prompt state, no-results shows empty state
  </verify>
  <done>
    - /memory/search provides cross-agent semantic search with debounced input
    - Results displayed as card grid with agent name, relevance indicator, highlighted snippet, and context
    - Optional agent filter dropdown narrows search scope
    - URL state persisted via nuqs for shareable search links
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Both /memory and /memory/search routes resolve without 404
- Memory browser shows agent-first organization with collapsible sections
- Memory preview is read-only (no edit/delete controls)
- Search returns relevance-scored results with highlighted snippets
- Agent filter works in search
</verification>

<success_criteria>
- MEMO-01: /memory shows memories organized by agent first, then by memory type, in read-only browser
- MEMO-02: /memory/search shows cross-agent semantic search with card grid results, agent filter, and relevance scoring
</success_criteria>

<output>
After completion, create `.planning/phases/08-sessions-memory-files-governance/08-02-SUMMARY.md`
</output>
