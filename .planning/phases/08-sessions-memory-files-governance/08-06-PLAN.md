---
phase: 08-sessions-memory-files-governance
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/entities/governance/model/types.ts
  - src/entities/governance/model/schemas.ts
  - src/entities/governance/index.ts
  - src/features/audit/api/use-audit-log.ts
  - src/features/audit/components/audit-log-table.tsx
  - src/features/audit/components/audit-detail-panel.tsx
  - src/features/governance/api/use-policies.ts
  - src/features/governance/api/use-policy-mutations.ts
  - src/features/governance/components/policy-list.tsx
  - src/features/governance/components/policy-rule-row.tsx
  - src/features/governance/components/condition-builder.tsx
  - src/views/audit/audit-log-view.tsx
  - src/views/governance/policies-view.tsx
  - app/(dashboard)/audit/page.tsx
  - app/(dashboard)/governance/policies/page.tsx
autonomous: true
requirements:
  - GOVR-03
  - GOVR-04

must_haves:
  truths:
    - "User can view immutable audit log at /audit with compact single-line entries"
    - "Audit entries are expandable to show before/after detail and metadata"
    - "Audit log supports filtering by actor, action type, resource type, and date range"
    - "User can define governance policies at /governance/policies using visual condition builder"
    - "Policy rules use IF [field] [operator] [value] THEN [action] format"
    - "Policies can be created, enabled/disabled, and deleted"
  artifacts:
    - path: "src/entities/governance/model/types.ts"
      provides: "GovernancePolicy, PolicyRule, PolicyCondition types"
      contains: "PolicyRule"
    - path: "src/entities/governance/model/schemas.ts"
      provides: "Zod v4 validation schemas for policy rules"
      contains: "policyRuleSchema"
    - path: "src/features/audit/components/audit-log-table.tsx"
      provides: "Compact DataTable with expandable rows"
      contains: "AuditLogTable"
    - path: "src/features/governance/components/condition-builder.tsx"
      provides: "Visual IF/THEN condition builder"
      contains: "ConditionBuilder"
    - path: "src/views/governance/policies-view.tsx"
      provides: "Governance policies page composition"
      contains: "PoliciesView"
  key_links:
    - from: "app/(dashboard)/audit/page.tsx"
      to: "src/views/audit/audit-log-view.tsx"
      via: "Next.js route -> view component"
      pattern: "AuditLogView"
    - from: "src/features/governance/components/condition-builder.tsx"
      to: "src/entities/governance/model/schemas.ts"
      via: "Zod validation"
      pattern: "policyRuleSchema"
    - from: "src/views/governance/policies-view.tsx"
      to: "src/features/governance/api/use-policies.ts"
      via: "TanStack Query hook"
      pattern: "usePolicies"
---

<objective>
Build the audit log viewer and governance policy editor: a compact, filterable audit log with expandable detail rows, and a visual policy condition builder where users define IF/THEN governance rules.

Purpose: Users need accountability (immutable audit trail of all actions) and control (defining policies that govern agent behavior like auto-approval rules, tool restrictions, and escalation triggers).

Output: Governance entity types with Zod v4 schemas, 3 TanStack Query hooks, 5 feature components, 2 view compositions, 2 route pages.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-sessions-memory-files-governance/08-RESEARCH.md (governance policy builder pattern, audit log pattern)

@src/shared/ui/data-table.tsx (DataTable with virtual scrolling)
@src/shared/ui/filter-bar.tsx (FilterBar component)
@src/features/audit/model/audit-schema.ts (existing Drizzle audit_logs schema from Phase 1)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit log viewer with compact entries, expandable detail, and filtering at /audit</name>
  <files>
    src/features/audit/api/use-audit-log.ts
    src/features/audit/components/audit-log-table.tsx
    src/features/audit/components/audit-detail-panel.tsx
    src/views/audit/audit-log-view.tsx
    app/(dashboard)/audit/page.tsx
  </files>
  <action>
    **use-audit-log.ts**: TanStack Query hook returning audit log entries. Define a local AuditLogEntry type (matching the existing Drizzle audit_logs schema shape): { id (string), timestamp (Date), actor (string -- user email or "system"), action (string -- "create"|"update"|"delete"|"approve"|"reject"|"login"|"logout"), resourceType (string -- "task"|"agent"|"session"|"file"|"policy"|"user"), resourceId (string), metadata (Record<string, unknown> | undefined), beforeState (Record<string, unknown> | undefined), afterState (Record<string, unknown> | undefined), ipAddress (string | undefined), correlationId (string | undefined), hashChainPrev (string | undefined) }.
    - Generate 30-50 mock audit entries spanning the last 7 days:
      - Mix of actions: user logins, task approvals, agent config changes, file uploads, policy updates.
      - Include beforeState/afterState for update actions (e.g., task status changed from "in_progress" to "done").
      - Some entries with metadata (IP addresses, user agents).
    - Support filters: { actor?, action?, resourceType?, dateFrom?, dateTo? }.
    - Default: last 7 days (per research Pitfall 5).
    - staleTime: 60000 (1 minute). Use queryKeys.audit.list(filters).

    **audit-detail-panel.tsx**: AuditDetailPanel component.
    - Takes AuditLogEntry as prop.
    - Renders expanded detail content for a log entry:
      - Full timestamp (date-fns format "yyyy-MM-dd HH:mm:ss").
      - Actor with user icon.
      - Resource link: "{resourceType}/{resourceId}" as clickable text.
      - Before/After diff (if update action): side-by-side JSON display. JSON.stringify(state, null, 2) in pre blocks with bg-muted. Before on left (text with red-ish bg for changed lines), after on right (green-ish bg for changed lines). For v1, simple side-by-side JSON is sufficient -- no fancy diff algorithm.
      - Metadata: key-value list if present (IP address, user agent, correlation ID).
      - Hash chain: small Shield icon with "Verified" or "Unverified" text. For mock, all entries are "Verified".
    - Compact: padding, border-t separator, bg-muted/50.

    **audit-log-table.tsx**: AuditLogTable component.
    - Takes AuditLogEntry[] as prop.
    - DataTable with columns:
      1. Timestamp: compact format "Feb 18, 14:23" (date-fns format "MMM dd, HH:mm")
      2. Actor: truncated to 20 chars, User icon for humans, Bot icon for system
      3. Action: colored badge (create=green, update=blue, delete=red, approve=green, reject=red, login=gray, logout=gray)
      4. Resource: "{type}: {id}" truncated
      5. Expand chevron icon
    - Row expansion: clicking a row or the expand chevron shows AuditDetailPanel below the row. Use React state to track expandedRowId (string | null). Only one row expanded at a time.
    - Compact rows: text-sm, py-2 for single-line feel.
    - Virtual scrolling enabled for performance (audit logs can be large).
    - Audit entries are immutable -- no edit/delete actions shown.

    **audit-log-view.tsx**: AuditLogView composition.
    - Uses useAuditLog() with filters from nuqs URL state.
    - PageHeader: "Audit Log" with description "Immutable record of all system actions".
    - FilterBar with:
      - Actor: text input filter
      - Action: multi-select (create, update, delete, approve, reject, login, logout)
      - Resource Type: select (task, agent, session, file, policy, user)
      - Date range: two date inputs (from/to) or use a simple "Last 7 days / Last 30 days / All time" select for simplicity
    - nuqs for all filter params: `actor`, `action`, `resource`, `period` (7d, 30d, all).
    - AuditLogTable with filtered data.
    - Loading skeleton: SkeletonTable.
    - Entry count: "Showing {count} entries" above table.

    **Route page**: Standard async server component, Suspense wrapper.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - /audit renders compact log entries in DataTable
    - Clicking a row expands to show detail with before/after state
    - Filters narrow results by actor, action, resource type, and period
    - No edit/delete controls visible (immutable)
  </verify>
  <done>
    - /audit shows compact single-line audit log entries
    - Row expansion shows before/after diff, metadata, and hash chain verification
    - Filters work for actor, action type, resource type, and time period
    - Virtual scrolling handles large log sets
    - All entries marked as immutable (no modification controls)
  </done>
</task>

<task type="auto">
  <name>Task 2: Governance policy entity types, Zod schemas, condition builder, and policies editor at /governance/policies</name>
  <files>
    src/entities/governance/model/types.ts
    src/entities/governance/model/schemas.ts
    src/entities/governance/index.ts
    src/features/governance/api/use-policies.ts
    src/features/governance/api/use-policy-mutations.ts
    src/features/governance/components/policy-list.tsx
    src/features/governance/components/policy-rule-row.tsx
    src/features/governance/components/condition-builder.tsx
    src/views/governance/policies-view.tsx
    app/(dashboard)/governance/policies/page.tsx
  </files>
  <action>
    **Entity types** (src/entities/governance/model/types.ts):
    - Define ConditionField: "agent" | "task_priority" | "cost" | "tool" | "task_status"
    - Define ConditionOperator: "equals" | "not_equals" | "greater_than" | "less_than" | "contains"
    - Define PolicyAction: "require_approval" | "block" | "notify" | "auto_approve"
    - Define PolicyCondition: { field (ConditionField), operator (ConditionOperator), value (string) }
    - Define PolicyRule: { id (string), name (string), description (string | undefined), conditions (PolicyCondition[]), action (PolicyAction), actionConfig (Record<string, string> | undefined), enabled (boolean), createdAt (Date), updatedAt (Date) }
    - Define display label maps: CONDITION_FIELD_LABELS, OPERATOR_LABELS, ACTION_LABELS for rendering human-readable labels in the UI.
    - All optional props use `| undefined`
    - Barrel export from index.ts

    **Zod schemas** (src/entities/governance/model/schemas.ts):
    - Import z from "zod/v4" (project convention).
    - policyConditionSchema: z.object({ field: z.enum([...fields]), operator: z.enum([...operators]), value: z.string().min(1, "Value is required") })
    - policyRuleSchema: z.object({ name: z.string().min(1, "Name required").max(100), description: z.string().max(500).optional(), conditions: z.array(policyConditionSchema).min(1, "At least one condition required"), action: z.enum([...actions]), actionConfig: z.record(z.string(), z.string()).optional(), enabled: z.boolean() })
    - Export types inferred from schemas.

    **use-policies.ts**: TanStack Query hook returning PolicyRule[].
    - Generate 3-4 mock policies:
      1. "Require approval for high-priority tasks" -- IF task_priority equals high THEN require_approval (enabled)
      2. "Block dangerous tools" -- IF tool contains "shell_exec" THEN block (enabled)
      3. "Auto-approve low-cost operations" -- IF cost less_than "1.00" THEN auto_approve (enabled)
      4. "Notify on agent errors" -- IF task_status equals "failed" THEN notify (disabled)
    - staleTime: Infinity. Use queryKeys.governance.policies().

    **use-policy-mutations.ts**: TanStack Query mutation hooks.
    - useCreatePolicy: accepts PolicyRule form data, mock 300ms delay, adds to cache optimistically, toast "Policy created".
    - useUpdatePolicy: accepts { id, data }, updates cache, toast "Policy updated".
    - useDeletePolicy: accepts id, removes from cache, toast "Policy deleted".
    - useTogglePolicy: accepts { id, enabled }, optimistic toggle in cache, toast "{name} enabled/disabled".
    - All invalidate queryKeys.governance.policies() on settled.

    **policy-rule-row.tsx**: PolicyRuleRow component.
    - Takes PolicyRule as prop, onEdit/onDelete/onToggle callbacks.
    - Card layout:
      - Header: rule name (font-medium), enabled/disabled Switch toggle, ActionMenu (Edit, Delete).
      - Body: visual condition display:
        - For each condition: "IF {field label} {operator label} {value}" rendered as inline badges/pills.
        - Multiple conditions joined with "AND" connector text.
        - "THEN {action label}" at the end in a distinct colored badge (green for auto_approve, red for block, blue for require_approval, yellow for notify).
      - Footer: description (if present, text-muted-foreground text-sm), dates (created, updated).
    - Disabled state: muted opacity, "Disabled" badge.

    **condition-builder.tsx**: ConditionBuilder form component.
    - Uses react-hook-form with zodResolver(policyRuleSchema) as never (project pattern for Zod v4).
    - Fields:
      - Name: text input
      - Description: optional textarea
      - Conditions: useFieldArray for dynamic condition rows. Each row:
        - Field: Select dropdown with options from ConditionField (label from CONDITION_FIELD_LABELS)
        - Operator: Select dropdown with options from ConditionOperator (label from OPERATOR_LABELS)
        - Value: text Input
        - Remove button (Trash2 icon, disabled if only 1 condition)
      - "+ Add condition" button below conditions (adds new empty row)
      - Action: Select dropdown with options from PolicyAction (label from ACTION_LABELS)
      - Enabled: Switch toggle
    - Submit button: "Create Policy" or "Update Policy" depending on mode.
    - Cancel button: resets form.
    - Renders in a Card or Sheet depending on context.
    - Validation errors shown inline per field.

    **policy-list.tsx**: PolicyList component.
    - Takes PolicyRule[] as prop.
    - Renders list of PolicyRuleRow components.
    - Empty state: EmptyState "No governance policies defined" with "Create your first policy" CTA.

    **policies-view.tsx**: PoliciesView composition.
    - Uses usePolicies() for data.
    - PageHeader: "Governance Policies" with description "Define rules that govern agent behavior" and "Create Policy" button.
    - "Create Policy" opens ConditionBuilder in a Sheet (slide-over from right).
    - PolicyList below header.
    - Edit: clicking edit on a PolicyRuleRow opens ConditionBuilder in Sheet with pre-filled form data.
    - Delete: confirmation dialog before deletion.
    - Toggle: immediate optimistic toggle via useTogglePolicy.
    - Loading skeleton: SkeletonCard x 3.

    **Route page**: Standard async server component, Suspense wrapper.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - /governance/policies renders policy list with condition display
    - Create Policy opens condition builder sheet
    - Can add/remove conditions in the builder
    - Form validation works (name required, at least 1 condition)
    - Enable/disable toggle works optimistically
    - Delete shows confirmation dialog
  </verify>
  <done>
    - /governance/policies shows list of governance rules with visual IF/THEN display
    - Users can create new policies via condition builder sheet
    - Condition builder supports adding/removing conditions with field/operator/value selects
    - Policies can be enabled/disabled via toggle, edited, and deleted
    - Form validated with Zod v4 schemas (zodResolver as-never pattern)
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Both /audit and /governance/policies routes resolve
- Audit log shows compact entries with working expansion and filtering
- Policy builder creates valid IF/THEN rules with Zod validation
- Policy toggle and delete work with optimistic updates
</verification>

<success_criteria>
- GOVR-03: /audit shows immutable audit log with compact entries, expandable detail, and filtering by actor/action/resource/date
- GOVR-04: /governance/policies shows visual condition builder for defining IF [field] [operator] [value] THEN [action] governance rules
</success_criteria>

<output>
After completion, create `.planning/phases/08-sessions-memory-files-governance/08-06-SUMMARY.md`
</output>
