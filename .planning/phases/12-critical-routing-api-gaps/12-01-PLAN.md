---
phase: 12-critical-routing-api-gaps
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/page.tsx
  - proxy.ts
  - app/api/alerts/notifications/route.ts
autonomous: true
requirements:
  - INFR-01
  - DASH-01
  - AUTH-06
  - MNTR-04

must_haves:
  truths:
    - "Only app/(dashboard)/page.tsx resolves to URL / — no route conflict with app/page.tsx"
    - "proxy.ts redirects authenticated users from /login to /dashboard in a single hop (no double redirect through /)"
    - "GET /api/alerts/notifications returns recent alert notifications as JSON array"
    - "Login → redirect → Dashboard flow completes without double redirect"
  artifacts:
    - path: "app/api/alerts/notifications/route.ts"
      provides: "GET handler for alert notifications with session validation and Drizzle left join"
      exports: ["GET"]
    - path: "proxy.ts"
      provides: "Auth redirect to /dashboard instead of /"
      contains: '"/dashboard"'
  key_links:
    - from: "app/api/alerts/notifications/route.ts"
      to: "src/features/dashboard/api/use-alert-notification-bridge.ts"
      via: "fetch /api/alerts/notifications?limit=10 in queryFn"
      pattern: "fetch.*api/alerts/notifications"
    - from: "app/api/alerts/notifications/route.ts"
      to: "src/features/dashboard/model/alert-schema.ts"
      via: "Drizzle leftJoin on alertNotifications + alertRules"
      pattern: "leftJoin.*alertRules"
    - from: "proxy.ts"
      to: "app/(dashboard)/dashboard/page.tsx"
      via: "redirect authenticated users from auth pages to /dashboard"
      pattern: 'new URL.*"/dashboard"'
---

<objective>
Resolve three critical integration gaps from the v1.0 audit: delete the route conflict at `/`, fix the proxy.ts double-redirect, and create the missing `/api/alerts/notifications` endpoint.

Purpose: These three gaps prevent clean routing (route conflict may cause build errors), add unnecessary latency (double redirect on login), and leave the alert notification bridge polling a non-existent endpoint.

Output: Clean route resolution, single-hop auth redirect, and a working alert notifications API endpoint that the existing `useAlertNotificationBridge` hook can poll.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-critical-routing-api-gaps/12-RESEARCH.md
@.planning/phases/12-critical-routing-api-gaps/12-CONTEXT.md

@proxy.ts
@app/page.tsx
@app/(dashboard)/page.tsx
@src/features/dashboard/api/use-alert-notification-bridge.ts
@src/features/dashboard/model/alert-schema.ts
@src/shared/lib/db.ts
@src/features/auth/lib/auth.ts
@src/shared/lib/query-keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Delete route conflict and fix proxy redirect target</name>
  <files>app/page.tsx, proxy.ts</files>
  <action>
1. **Delete `app/page.tsx`** — This is the Next.js scaffolding splash page (shows "AXion Hub" heading with color swatches). It conflicts with `app/(dashboard)/page.tsx` because both resolve to URL `/`. The file has no imports, consumers, or test coverage. After deletion, `app/(dashboard)/page.tsx` becomes the sole handler for `/` and its `redirect("/dashboard")` call routes users to the actual dashboard.

2. **Fix `proxy.ts` line 32** — Change the redirect target from `"/"` to `"/dashboard"`. Currently, when an authenticated user visits `/login`, proxy.ts redirects to `/`, which then triggers `app/(dashboard)/page.tsx` to redirect again to `/dashboard` — a double redirect. Changing the target to `"/dashboard"` eliminates the intermediate hop.

   In `proxy.ts`, change:
   ```
   return NextResponse.redirect(new URL("/", request.url));
   ```
   to:
   ```
   return NextResponse.redirect(new URL("/dashboard", request.url));
   ```

   This is line 32 inside the `if (isAuthPage && sessionCookie)` block. No other lines in the file change.

Do NOT:
- Add a new `app/page.tsx` as a redirect stub (the route group already handles it)
- Modify `app/(dashboard)/page.tsx` (it correctly redirects to `/dashboard`)
- Touch `middleware.ts` (it simply re-exports from proxy.ts)
  </action>
  <verify>
1. Confirm `app/page.tsx` does not exist: `ls app/page.tsx` should fail with "No such file"
2. Confirm proxy.ts line 32 contains `"/dashboard"`: `grep -n '"/dashboard"' proxy.ts`
3. Confirm `app/(dashboard)/page.tsx` still exists and contains `redirect("/dashboard")`
  </verify>
  <done>
- `app/page.tsx` is deleted — no route conflict
- proxy.ts redirects authenticated users from auth pages to `/dashboard` (single hop)
- `app/(dashboard)/page.tsx` remains the sole handler for URL `/`
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/alerts/notifications endpoint</name>
  <files>app/api/alerts/notifications/route.ts</files>
  <action>
Create `app/api/alerts/notifications/route.ts` with a GET handler that returns recent alert notifications. This endpoint is already polled by `useAlertNotificationBridge` (every 30s via TanStack Query at `fetch("/api/alerts/notifications?limit=10")`). The query key already exists in `query-keys.ts` at `queryKeys.alerts.notifications()`. Do NOT add any new query keys.

**Implementation details (per CONTEXT.md locked decisions):**

1. **Session validation (defense-in-depth):**
   - Import `auth` from `@/features/auth/lib/auth`
   - Import `headers` from `next/headers`
   - Call `auth.api.getSession({ headers: await headers() })`
   - If no session, return `Response.json({ error: "Unauthorized" }, { status: 401 })`

2. **Query parameter parsing:**
   - Accept `?limit=N` query param from `request.nextUrl.searchParams`
   - Default 10, capped at 50: `Math.min(Math.max(Number(limitParam) || 10, 1), 50)`
   - No Zod validation — simple numeric clamping is sufficient for a single param

3. **Database query:**
   - Import `db` from `@/shared/lib/db`
   - Import `alertNotifications` and `alertRules` from `@/features/dashboard/model/alert-schema`
   - Import `desc` and `eq` from `drizzle-orm`
   - Use `db.select({...}).from(alertNotifications).leftJoin(alertRules, eq(alertNotifications.ruleId, alertRules.id)).orderBy(desc(alertNotifications.createdAt)).limit(limit)`
   - Select exactly these columns: `id`, `ruleId`, `ruleName` (from `alertRules.name`), `severity`, `message`, `createdAt`, `read`
   - `ruleName` will be `string | null` due to LEFT JOIN — this is correct, the bridge handles fallback to "Alert"

4. **Response:**
   - Return `Response.json(rows)` — `Response.json()` automatically serializes Date to ISO string
   - Return empty array `[]` if no notifications (not an error)

5. **Import `NextRequest` type** from `next/server` for the request parameter typing.

Do NOT:
- Add mark-as-read functionality (deferred per CONTEXT.md)
- Add read/unread filtering (deferred per CONTEXT.md)
- Add new query keys to `query-keys.ts` (already exists at `queryKeys.alerts.notifications()`)
- Use `db.query` relational API (project uses SQL-like `db.select().from()` pattern exclusively)
- Use `new Response(JSON.stringify(data))` — use `Response.json(data)` for correct Date serialization
  </action>
  <verify>
1. Confirm file exists: `ls app/api/alerts/notifications/route.ts`
2. Confirm it exports a GET function: `grep "export async function GET" app/api/alerts/notifications/route.ts`
3. Confirm it imports from alert-schema: `grep "alert-schema" app/api/alerts/notifications/route.ts`
4. Confirm it uses leftJoin: `grep "leftJoin" app/api/alerts/notifications/route.ts`
5. Confirm it validates session: `grep "getSession" app/api/alerts/notifications/route.ts`
6. TypeScript compiles: `npx tsc --noEmit --pretty 2>&1 | head -20` (no errors in this file)
  </verify>
  <done>
- GET `/api/alerts/notifications` endpoint exists and returns `RawAlertNotification[]` shape
- Session validation returns 401 for unauthenticated requests
- LEFT JOIN on alertRules provides nullable `ruleName`
- Limit parameter accepted with default 10, capped at 50
- Results ordered by `createdAt` DESC
- `useAlertNotificationBridge` can now successfully poll and populate the alert store
  </done>
</task>

</tasks>

<verification>
1. `app/page.tsx` does not exist (route conflict eliminated)
2. `proxy.ts` redirects to `/dashboard` (single-hop redirect)
3. `app/api/alerts/notifications/route.ts` exists with GET handler
4. TypeScript compiles without errors in modified files
5. The response shape matches `RawAlertNotification` interface in `use-alert-notification-bridge.ts`: `{ id, ruleId, ruleName, severity, message, createdAt, read }`
</verification>

<success_criteria>
- No route conflict: only `app/(dashboard)/page.tsx` resolves to URL `/`
- Single-hop redirect: authenticated user visiting `/login` goes directly to `/dashboard`
- Alert notifications API returns valid JSON array matching the bridge's expected shape
- All four phase requirement IDs (INFR-01, DASH-01, AUTH-06, MNTR-04) are addressed
</success_criteria>

<output>
After completion, create `.planning/phases/12-critical-routing-api-gaps/12-01-SUMMARY.md`
</output>
