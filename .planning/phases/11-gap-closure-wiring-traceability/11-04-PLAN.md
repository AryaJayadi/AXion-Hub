---
phase: 11-gap-closure-wiring-traceability
plan: 04
type: execute
wave: 3
depends_on: []
files_modified:
  - middleware.ts
  - src/features/dashboard/api/use-alert-notification-bridge.ts
  - src/features/dashboard/components/notification-bell.tsx
  - src/app/providers/app-providers.tsx
autonomous: true
requirements:
  - AUTH-06
  - MNTR-04

must_haves:
  truths:
    - "middleware.ts exists at project root with edge-level auth protection"
    - "Unauthenticated requests to protected routes redirect to /login"
    - "Authenticated users on auth pages (/login, /register) redirect to /dashboard"
    - "Public paths (/api/auth, /login, /register, static assets) pass through without redirect"
    - "Alert notifications poll from API and push new alerts to Zustand store"
    - "New alerts trigger sonner toast notifications"
    - "NotificationBell alert items navigate to /monitor/alerts when clicked"
  artifacts:
    - path: "middleware.ts"
      provides: "Edge-level route protection using better-auth getSessionCookie"
      contains: "getSessionCookie"
    - path: "src/features/dashboard/api/use-alert-notification-bridge.ts"
      provides: "TanStack Query polling hook that bridges DB alerts to Zustand store + sonner toasts"
      contains: "refetchInterval"
    - path: "src/features/dashboard/components/notification-bell.tsx"
      provides: "NotificationBell with clickable alert items navigating to /monitor/alerts"
      contains: "/monitor/alerts"
  key_links:
    - from: "middleware.ts"
      to: "better-auth/cookies"
      via: "getSessionCookie import"
      pattern: "getSessionCookie"
    - from: "src/features/dashboard/api/use-alert-notification-bridge.ts"
      to: "src/features/dashboard/model/alert-store.ts"
      via: "useAlertStore addAlert action"
      pattern: "addAlert"
    - from: "src/features/dashboard/api/use-alert-notification-bridge.ts"
      to: "sonner"
      via: "toast() call on new notifications"
      pattern: "toast\\."
---

<objective>
Create edge-level auth middleware and wire the alert notification bridge (DB polling to Zustand to toast).

Purpose: The project has no middleware.ts — all auth checks happen at layout level, meaning unauthenticated users still trigger RSC rendering before being redirected. The alert notification system writes to the DB but nothing reads alerts back to the client UI.
Output: middleware.ts at project root with optimistic cookie check; alert notification bridge that polls, pushes to Zustand, and fires toasts.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/features/auth/lib/auth.ts
@src/features/auth/lib/auth-client.ts
@src/features/dashboard/model/alert-store.ts
@src/features/dashboard/model/alert-schema.ts
@src/features/dashboard/components/notification-bell.tsx
@src/shared/lib/query-keys.ts
@app/(dashboard)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create edge-level auth middleware</name>
  <files>middleware.ts</files>
  <action>
Create `middleware.ts` at the project root (Next.js convention for edge middleware).

Use `getSessionCookie` from `better-auth/cookies` for an optimistic cookie-existence check. This does NOT validate the cookie — the actual secure validation happens in the dashboard layout.tsx server component via `auth.api.getSession()`. The middleware prevents unnecessary RSC rendering for unauthenticated users.

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getSessionCookie } from "better-auth/cookies";

// Pages that should be accessible without authentication
const AUTH_PAGES = ["/login", "/register", "/forgot-password", "/reset-password"];
const PUBLIC_PATHS = [
    ...AUTH_PAGES,
    "/verify-email",
    "/invite",
    "/api/auth",
    "/api/health",
];

export async function middleware(request: NextRequest) {
    const sessionCookie = getSessionCookie(request);
    const { pathname } = request.nextUrl;

    // Allow public paths through
    const isPublic = PUBLIC_PATHS.some((p) => pathname.startsWith(p));
    if (isPublic) {
        // Redirect authenticated users away from auth pages to dashboard
        if (sessionCookie && AUTH_PAGES.some((p) => pathname.startsWith(p))) {
            return NextResponse.redirect(new URL("/dashboard", request.url));
        }
        return NextResponse.next();
    }

    // Root path: redirect to dashboard or login based on auth
    if (pathname === "/") {
        return NextResponse.redirect(
            new URL(sessionCookie ? "/dashboard" : "/login", request.url),
        );
    }

    // Protected routes: redirect to login if no session cookie
    if (!sessionCookie) {
        const callbackUrl = encodeURIComponent(pathname);
        return NextResponse.redirect(
            new URL(`/login?callbackUrl=${callbackUrl}`, request.url),
        );
    }

    return NextResponse.next();
}

export const config = {
    matcher: [
        /*
         * Match all request paths except:
         * - _next/static (static files)
         * - _next/image (image optimization)
         * - favicon.ico (browser icon)
         * - Common static file extensions
         */
        "/((?!_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico)).*)",
    ],
};
```

Key decisions:
- `/api/auth` must be public (better-auth API routes)
- `/api/health` must be public (Docker health checks)
- `/invite` must be public (invitation acceptance before auth)
- `/verify-email` must be public (email verification before auth)
- Root `/` redirects to `/dashboard` if authenticated, `/login` if not
- The matcher excludes static assets to prevent redirect loops (per Research Pitfall 2)
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors. Verify middleware.ts exists at project root (NOT in src/ or app/). Verify it imports `getSessionCookie` from `better-auth/cookies`. Verify the matcher excludes static assets.
  </verify>
  <done>
middleware.ts exists at project root with edge-level cookie check. Unauthenticated users redirect to /login with callbackUrl. Authenticated users on auth pages redirect to /dashboard. Static assets and public paths pass through.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire alert notification bridge and NotificationBell navigation</name>
  <files>
    src/features/dashboard/api/use-alert-notification-bridge.ts
    src/features/dashboard/components/notification-bell.tsx
    src/app/providers/app-providers.tsx
  </files>
  <action>
**Part A: Create the alert notification bridge hook**

Create `src/features/dashboard/api/use-alert-notification-bridge.ts`:

```typescript
"use client";

import { useQuery } from "@tanstack/react-query";
import { useRef, useEffect } from "react";
import { toast } from "sonner";
import { useAlertStore } from "../model/alert-store";
import type { AlertNotification } from "../model/alert-store";
import { queryKeys } from "@/shared/lib/query-keys";

interface RawAlertNotification {
    id: string;
    ruleId: string;
    ruleName: string | null;
    severity: "critical" | "warning" | "info";
    message: string;
    createdAt: string;
    read: boolean;
}

/**
 * Bridges alert notifications from the database to the client UI.
 *
 * Polls GET /api/alerts/notifications every 30 seconds. When new
 * notifications arrive (newer than the last-seen ID), pushes each
 * into the Zustand alertStore and fires a sonner toast.
 *
 * Mount this once in AppProviders or the dashboard layout.
 */
export function useAlertNotificationBridge() {
    const addAlert = useAlertStore((s) => s.addAlert);
    const lastSeenIdRef = useRef<string | null>(null);

    const { data: notifications } = useQuery({
        queryKey: queryKeys.alerts.notifications(),
        queryFn: async (): Promise<RawAlertNotification[]> => {
            try {
                const res = await fetch("/api/alerts/notifications?limit=10");
                if (!res.ok) return [];
                return res.json();
            } catch {
                return [];
            }
        },
        refetchInterval: 30_000,
        staleTime: 15_000,
    });

    useEffect(() => {
        if (!notifications?.length) return;

        const newest = notifications[0];
        if (!newest || newest.id === lastSeenIdRef.current) return;

        // Find notifications newer than last seen
        const lastIdx = lastSeenIdRef.current
            ? notifications.findIndex((n) => n.id === lastSeenIdRef.current)
            : notifications.length;

        const newOnes = notifications.slice(
            0,
            lastIdx === -1 ? notifications.length : lastIdx,
        );

        // Process from oldest to newest
        for (const n of [...newOnes].reverse()) {
            addAlert({
                id: n.id,
                ruleId: n.ruleId,
                ruleName: n.ruleName ?? "Alert",
                severity: n.severity,
                message: n.message,
                timestamp: new Date(n.createdAt),
                read: n.read,
            });

            if (!n.read) {
                toast.warning(n.message, {
                    description: n.ruleName ?? "Alert",
                    duration: 8000,
                });
            }
        }

        lastSeenIdRef.current = newest.id;
    }, [notifications, addAlert]);
}
```

Key implementation details:
- Uses `useRef` to track last-seen ID, preventing duplicate toast firings (Research Pitfall 3)
- Only fires toasts for unread notifications
- Polls every 30s with 15s staleTime (TanStack Query handles deduplication)
- Graceful error handling: returns empty array on fetch failure
- Processes new notifications from oldest to newest for correct ordering

**Part B: Mount the bridge in AppProviders**

Open `src/app/providers/app-providers.tsx` and add the bridge hook. Since hooks must be called inside a component, create a small internal component:

```typescript
import { useAlertNotificationBridge } from "@/features/dashboard/api/use-alert-notification-bridge";

// Inside the AppProviders component, add a child component that activates the bridge:
function AlertBridge() {
    useAlertNotificationBridge();
    return null;
}
```

Then render `<AlertBridge />` inside the provider tree (after QueryClientProvider so TanStack Query is available). Place it as a sibling to other provider children, NOT wrapping them.

**Part C: Add navigation to NotificationBell alert items**

Update `src/features/dashboard/components/notification-bell.tsx`:

1. Add `useRouter` import: `import { useRouter } from "next/navigation";`
2. Inside the `NotificationBell` component, add: `const router = useRouter();`
3. Add `markRead` from the store: `const markRead = useAlertStore((s) => s.markRead);`
4. Make each alert item clickable and navigate to /monitor/alerts:

Replace the alert item `<div>` with a `<button>`:
```typescript
<button
    key={alert.id}
    type="button"
    onClick={() => {
        markRead(alert.id);
        router.push("/monitor/alerts");
    }}
    className={cn(
        "flex w-full items-start gap-3 border-b px-4 py-3 text-left last:border-b-0 transition-colors hover:bg-muted/50",
        !alert.read && "bg-muted/30",
    )}
>
```
Change the closing `</div>` to `</button>` accordingly.

5. Add a "View all" link at the bottom of the popover content, after the alert list:
```typescript
<div className="border-t p-2">
    <Button
        variant="ghost"
        size="sm"
        className="w-full text-xs"
        onClick={() => router.push("/monitor/alerts")}
    >
        View all alerts
    </Button>
</div>
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors. Verify: (a) use-alert-notification-bridge.ts exists and exports the hook, (b) AppProviders renders AlertBridge component, (c) NotificationBell alert items are clickable buttons that navigate to /monitor/alerts, (d) "View all alerts" link is present.
  </verify>
  <done>
Alert notification bridge polls /api/alerts/notifications every 30s, pushes new alerts to Zustand store, and fires sonner toasts for unread alerts. NotificationBell alert items are clickable and navigate to /monitor/alerts. "View all alerts" link is present at the bottom of the dropdown.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. middleware.ts exists at project root (not in src/)
3. middleware.ts uses getSessionCookie from better-auth/cookies
4. Protected routes redirect to /login when no session cookie
5. Auth pages redirect to /dashboard when session cookie exists
6. Alert bridge hook mounts in AppProviders
7. Alert bridge polls every 30s and deduplicates with lastSeenIdRef
8. NotificationBell items navigate to /monitor/alerts on click
9. No new npm dependencies required
</verification>

<success_criteria>
- middleware.ts provides edge-level auth protection with optimistic cookie check
- Alert notification bridge polls DB and pushes to Zustand + sonner toast
- NotificationBell alert items are clickable and navigate to /monitor/alerts
- All changes are backwards-compatible with existing auth flow (layout-level validation)
</success_criteria>

<output>
After completion, create `.planning/phases/11-gap-closure-wiring-traceability/11-04-SUMMARY.md`
</output>
