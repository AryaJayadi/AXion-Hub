---
phase: 11-gap-closure-wiring-traceability
plan: 04
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - middleware.ts
  - src/features/dashboard/api/use-alert-notification-bridge.ts
  - src/features/dashboard/components/notification-bell.tsx
  - src/app/providers/app-providers.tsx
autonomous: true
requirements:
  - AUTH-06
  - MNTR-04

must_haves:
  truths:
    - "middleware.ts exists at project root with edge-level auth protection"
    - "Unauthenticated requests to protected routes redirect to /login"
    - "Authenticated users on auth pages (/login, /register) redirect to /dashboard"
    - "Public paths (/api/auth, /login, /register, static assets) pass through without redirect"
    - "Alert notifications poll from API and push new alerts to Zustand store"
    - "New alerts trigger sonner toast notifications"
    - "NotificationBell alert items navigate to /monitor/alerts when clicked"
  artifacts:
    - path: "middleware.ts"
      provides: "Edge-level route protection mounting proxy.ts"
      contains: "proxy as middleware"
    - path: "src/features/dashboard/api/use-alert-notification-bridge.ts"
      provides: "TanStack Query polling hook that bridges DB alerts to Zustand store + sonner toasts"
      contains: "refetchInterval"
    - path: "src/features/dashboard/components/notification-bell.tsx"
      provides: "NotificationBell with clickable alert items navigating to /monitor/alerts"
      contains: "/monitor/alerts"
  key_links:
    - from: "middleware.ts"
      to: "proxy.ts"
      via: "re-export proxy as middleware"
      pattern: "proxy as middleware"
    - from: "src/features/dashboard/api/use-alert-notification-bridge.ts"
      to: "src/features/dashboard/model/alert-store.ts"
      via: "useAlertStore addAlert action"
      pattern: "addAlert"
    - from: "src/features/dashboard/api/use-alert-notification-bridge.ts"
      to: "sonner"
      via: "toast() call on new notifications"
      pattern: "toast\\."
---

<objective>
Create edge-level auth middleware and wire the alert notification bridge (DB polling to Zustand to toast).

Purpose: The project has no middleware.ts — all auth checks happen at layout level, meaning unauthenticated users still trigger RSC rendering before being redirected. The alert notification system writes to the DB but nothing reads alerts back to the client UI.
Output: middleware.ts at project root with optimistic cookie check; alert notification bridge that polls, pushes to Zustand, and fires toasts.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/features/auth/lib/auth.ts
@src/features/auth/lib/auth-client.ts
@src/features/dashboard/model/alert-store.ts
@src/features/dashboard/model/alert-schema.ts
@src/features/dashboard/components/notification-bell.tsx
@src/shared/lib/query-keys.ts
@app/(dashboard)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create middleware.ts mounting existing proxy.ts</name>
  <files>middleware.ts</files>
  <action>
Create `middleware.ts` at the project root (Next.js convention for edge middleware).

The complete auth logic already exists in `proxy.ts` at the project root. It exports a `proxy` function and a `config` object with matcher. The middleware.ts file simply re-exports these with the correct names that Next.js expects:

```typescript
export { proxy as middleware, config } from "./proxy";
```

That is the entire file — 1 line of code. Do NOT duplicate any auth logic from proxy.ts.

The existing proxy.ts already handles:
- Auth page redirect for logged-in users (AUTH_PAGES)
- Public path passthrough (PUBLIC_PATHS including /api/auth, /api/health, /api/audit/test)
- Protected route redirect to /login with callbackUrl
- Static asset exclusion via matcher config
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors. Verify middleware.ts exists at project root (NOT in src/ or app/). Verify it is a single re-export line mounting proxy.ts. Verify it does NOT contain any auth logic directly — all logic lives in proxy.ts.
  </verify>
  <done>
middleware.ts exists at project root, re-exporting proxy as middleware from ./proxy. Edge-level auth protection is active via the existing proxy.ts logic. No code duplication.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire alert notification bridge and NotificationBell navigation</name>
  <files>
    src/features/dashboard/api/use-alert-notification-bridge.ts
    src/features/dashboard/components/notification-bell.tsx
    src/app/providers/app-providers.tsx
  </files>
  <action>
**Part A: Create the alert notification bridge hook**

Create `src/features/dashboard/api/use-alert-notification-bridge.ts`:

```typescript
"use client";

import { useQuery } from "@tanstack/react-query";
import { useRef, useEffect } from "react";
import { toast } from "sonner";
import { useAlertStore } from "../model/alert-store";
import type { AlertNotification } from "../model/alert-store";
import { queryKeys } from "@/shared/lib/query-keys";

interface RawAlertNotification {
    id: string;
    ruleId: string;
    ruleName: string | null;
    severity: "critical" | "warning" | "info";
    message: string;
    createdAt: string;
    read: boolean;
}

/**
 * Bridges alert notifications from the database to the client UI.
 *
 * Polls GET /api/alerts/notifications every 30 seconds. When new
 * notifications arrive (newer than the last-seen ID), pushes each
 * into the Zustand alertStore and fires a sonner toast.
 *
 * Mount this once in AppProviders or the dashboard layout.
 */
export function useAlertNotificationBridge() {
    const addAlert = useAlertStore((s) => s.addAlert);
    const lastSeenIdRef = useRef<string | null>(null);

    const { data: notifications } = useQuery({
        queryKey: queryKeys.alerts.notifications(),
        queryFn: async (): Promise<RawAlertNotification[]> => {
            try {
                const res = await fetch("/api/alerts/notifications?limit=10");
                if (!res.ok) return [];
                return res.json();
            } catch {
                return [];
            }
        },
        refetchInterval: 30_000,
        staleTime: 15_000,
    });

    useEffect(() => {
        if (!notifications?.length) return;

        const newest = notifications[0];
        if (!newest || newest.id === lastSeenIdRef.current) return;

        // Find notifications newer than last seen
        const lastIdx = lastSeenIdRef.current
            ? notifications.findIndex((n) => n.id === lastSeenIdRef.current)
            : notifications.length;

        const newOnes = notifications.slice(
            0,
            lastIdx === -1 ? notifications.length : lastIdx,
        );

        // Process from oldest to newest
        for (const n of [...newOnes].reverse()) {
            addAlert({
                id: n.id,
                ruleId: n.ruleId,
                ruleName: n.ruleName ?? "Alert",
                severity: n.severity,
                message: n.message,
                timestamp: new Date(n.createdAt),
                read: n.read,
            });

            if (!n.read) {
                toast.warning(n.message, {
                    description: n.ruleName ?? "Alert",
                    duration: 8000,
                });
            }
        }

        lastSeenIdRef.current = newest.id;
    }, [notifications, addAlert]);
}
```

Key implementation details:
- Uses `useRef` to track last-seen ID, preventing duplicate toast firings (Research Pitfall 3)
- Only fires toasts for unread notifications
- Polls every 30s with 15s staleTime (TanStack Query handles deduplication)
- Graceful error handling: returns empty array on fetch failure
- Processes new notifications from oldest to newest for correct ordering

**Part B: Mount the bridge in AppProviders**

Open `src/app/providers/app-providers.tsx` and add the bridge hook. Since hooks must be called inside a component, create a small internal component:

```typescript
import { useAlertNotificationBridge } from "@/features/dashboard/api/use-alert-notification-bridge";

// Inside the AppProviders component, add a child component that activates the bridge:
function AlertBridge() {
    useAlertNotificationBridge();
    return null;
}
```

Then render `<AlertBridge />` inside the provider tree (after QueryClientProvider so TanStack Query is available). Place it as a sibling to other provider children, NOT wrapping them.

**Part C: Add navigation to NotificationBell alert items**

Update `src/features/dashboard/components/notification-bell.tsx`:

1. Add `useRouter` import: `import { useRouter } from "next/navigation";`
2. Inside the `NotificationBell` component, add: `const router = useRouter();`
3. Add `markRead` from the store: `const markRead = useAlertStore((s) => s.markRead);`
4. Make each alert item clickable and navigate to /monitor/alerts:

Replace the alert item `<div>` with a `<button>`:
```typescript
<button
    key={alert.id}
    type="button"
    onClick={() => {
        markRead(alert.id);
        router.push("/monitor/alerts");
    }}
    className={cn(
        "flex w-full items-start gap-3 border-b px-4 py-3 text-left last:border-b-0 transition-colors hover:bg-muted/50",
        !alert.read && "bg-muted/30",
    )}
>
```
Change the closing `</div>` to `</button>` accordingly.

5. Add a "View all" link at the bottom of the popover content, after the alert list:
```typescript
<div className="border-t p-2">
    <Button
        variant="ghost"
        size="sm"
        className="w-full text-xs"
        onClick={() => router.push("/monitor/alerts")}
    >
        View all alerts
    </Button>
</div>
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors. Verify: (a) use-alert-notification-bridge.ts exists and exports the hook, (b) AppProviders renders AlertBridge component, (c) NotificationBell alert items are clickable buttons that navigate to /monitor/alerts, (d) "View all alerts" link is present.
  </verify>
  <done>
Alert notification bridge polls /api/alerts/notifications every 30s, pushes new alerts to Zustand store, and fires sonner toasts for unread alerts. NotificationBell alert items are clickable and navigate to /monitor/alerts. "View all alerts" link is present at the bottom of the dropdown.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. middleware.ts exists at project root (not in src/)
3. middleware.ts is a single re-export line mounting proxy.ts (no duplicated logic)
4. proxy.ts already handles protected route redirect and auth page redirect
6. Alert bridge hook mounts in AppProviders
7. Alert bridge polls every 30s and deduplicates with lastSeenIdRef
8. NotificationBell items navigate to /monitor/alerts on click
9. No new npm dependencies required
</verification>

<success_criteria>
- middleware.ts mounts proxy.ts for edge-level auth protection (no duplicated logic)
- Alert notification bridge polls DB and pushes to Zustand + sonner toast
- NotificationBell alert items are clickable and navigate to /monitor/alerts
- All changes are backwards-compatible with existing auth flow (layout-level validation)
</success_criteria>

<output>
After completion, create `.planning/phases/11-gap-closure-wiring-traceability/11-04-SUMMARY.md`
</output>
