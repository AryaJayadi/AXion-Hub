---
phase: 11-gap-closure-wiring-traceability
plan: 02
type: execute
wave: 2
depends_on: []
files_modified:
  - src/features/chat/components/agent-picker-dialog.tsx
  - src/features/chat/components/conversation-sidebar.tsx
  - src/features/chat/components/chat-layout.tsx
  - src/views/chat/chat-hub-view.tsx
autonomous: true
requirements:
  - CHAT-01
  - AGNT-01

must_haves:
  truths:
    - "Clicking 'New Chat' button in ChatHubView empty state opens the AgentPickerDialog"
    - "Clicking 'Start Chat' button in ConversationSidebar empty state opens the AgentPickerDialog"
    - "AgentPickerDialog shows agents from Zustand store (shared cache with useAgents)"
    - "Creating an agent at /agents/new makes it appear in AgentPickerDialog without page refresh"
    - "After selecting an agent in picker, user navigates to /chat/[agentId]"
  artifacts:
    - path: "src/features/chat/components/agent-picker-dialog.tsx"
      provides: "Agent picker reading from Zustand store instead of separate TanStack Query"
      contains: "useAgentStore"
    - path: "src/views/chat/chat-hub-view.tsx"
      provides: "New Chat button wired to AgentPickerDialog open callback"
      contains: "onNewChat"
    - path: "src/features/chat/components/conversation-sidebar.tsx"
      provides: "Start Chat empty state wired to onNewChat callback"
      contains: "onNewChat"
  key_links:
    - from: "src/views/chat/chat-hub-view.tsx"
      to: "src/features/chat/components/chat-layout.tsx"
      via: "onNewChat callback from ChatLayout context"
      pattern: "onNewChat"
    - from: "src/features/chat/components/agent-picker-dialog.tsx"
      to: "src/features/agents/model/agent-store.ts"
      via: "useAgentStore selector"
      pattern: "useAgentStore"
---

<objective>
Wire chat entry points ("New Chat" and "Start Chat" buttons) to the AgentPickerDialog and fix the TanStack Query key mismatch so new agents appear instantly.

Purpose: Users currently cannot start new conversations from the chat hub or conversation sidebar empty state because the onClick handlers are no-ops. Additionally, agents created via the wizard don't appear in the picker due to separate query caches.
Output: Working chat flow where New Chat/Start Chat open the picker, agents are loaded from Zustand (shared with useAgents), and selecting an agent navigates to the conversation.
</objective>

<execution_context>
@/home/arya/.claude/get-shit-done/workflows/execute-plan.md
@/home/arya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/features/chat/components/chat-layout.tsx
@src/features/chat/components/agent-picker-dialog.tsx
@src/features/chat/components/conversation-sidebar.tsx
@src/views/chat/chat-hub-view.tsx
@src/features/agents/api/use-agents.ts
@src/features/agents/model/agent-store.ts
@src/shared/lib/query-keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix AgentPickerDialog to read from Zustand store</name>
  <files>src/features/chat/components/agent-picker-dialog.tsx</files>
  <action>
Update `src/features/chat/components/agent-picker-dialog.tsx` to read agents from Zustand instead of making its own TanStack Query call:

1. **Remove** the `useQuery` import from `@tanstack/react-query`.
2. **Remove** the `useGateway` import from `@/app/providers/gateway-provider`.
3. **Remove** the `queryKeys` import from `@/shared/lib/query-keys`.
4. **Add** import: `import { useAgentStore } from "@/features/agents/model/agent-store";`
5. **Replace** the entire `useQuery` block:
   ```typescript
   // Before:
   const { gatewayClient } = useGateway();
   const { data: agents = [] } = useQuery({
       queryKey: queryKeys.agents.lists(),
       queryFn: async () => { ... },
       staleTime: 30_000,
       enabled: open,
   });

   // After:
   const agents = useAgentStore((s) => s.agents);
   ```

This eliminates the query key mismatch (`['agents', 'list']` vs `['agents']`). Now the AgentPickerDialog reads from the same Zustand store that `useAgents` syncs to, so newly created agents appear instantly via the WebSocket Event Bus updates.

The `gatewayClient` and `queryKeys` are no longer used in this component.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors. Verify the file no longer imports `useQuery`, `useGateway`, or `queryKeys`. Verify it imports and uses `useAgentStore`.
  </verify>
  <done>
AgentPickerDialog reads agents from Zustand store (shared source of truth with useAgents hook). No separate TanStack Query call. New agents appear instantly without page refresh.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire chat entry points to AgentPickerDialog</name>
  <files>
    src/features/chat/components/conversation-sidebar.tsx
    src/features/chat/components/chat-layout.tsx
    src/views/chat/chat-hub-view.tsx
  </files>
  <action>
Three changes to wire the "New Chat" and "Start Chat" buttons:

**1. Fix ConversationSidebar empty state (conversation-sidebar.tsx):**
The empty state `onClick` is a no-op with a TODO comment. Replace:
```typescript
action={{
    label: "Start Chat",
    onClick: () => {
        /* Agent picker dialog will be wired in 04-02 */
    },
}}
```
With:
```typescript
action={{
    label: "Start Chat",
    ...(onNewChat ? { onClick: onNewChat } : {}),
}}
```
Use conditional spread because `onNewChat` is optional and the project uses `exactOptionalPropertyTypes`.

**2. Expose onNewChat callback from ChatLayout to children (chat-layout.tsx):**
ChatLayout owns the `agentPickerOpen` state but children (like ChatHubView) can't access it. Create a React context:

a. Create a `ChatLayoutContext` using `createContext`:
```typescript
import { createContext, useContext } from "react";

interface ChatLayoutContextValue {
    onNewChat: () => void;
}

const ChatLayoutContext = createContext<ChatLayoutContextValue | null>(null);

export function useChatLayoutContext() {
    const ctx = useContext(ChatLayoutContext);
    if (!ctx) throw new Error("useChatLayoutContext must be used within ChatLayout");
    return ctx;
}
```

b. Wrap the ChatLayout's return JSX with `<ChatLayoutContext.Provider value={{ onNewChat: handleOpenAgentPicker }}>`.

Put the context type, createContext, and useChatLayoutContext hook in the same file (chat-layout.tsx) since it's tightly coupled. Export `useChatLayoutContext` for use by ChatHubView.

**3. Wire ChatHubView "New Chat" button (chat-hub-view.tsx):**
Import `useChatLayoutContext` from chat-layout and wire the EmptyState action:

```typescript
import { ChatLayout, useChatLayoutContext } from "@/features/chat/components/chat-layout";

// Separate inner component that consumes context
function ChatHubContent() {
    const { onNewChat } = useChatLayoutContext();
    return (
        <div className="flex h-full items-center justify-center">
            <EmptyState
                icon={<MessageSquare className="size-12 text-muted-foreground/40" />}
                title="Select a conversation"
                description="Pick a conversation from the sidebar or start a new chat with an agent."
                action={{
                    label: "New Chat",
                    onClick: onNewChat,
                }}
            />
        </div>
    );
}

export function ChatHubView() {
    return (
        <ChatLayout showParticipants={false}>
            <ChatHubContent />
        </ChatLayout>
    );
}
```

This pattern separates the ChatLayout wrapper (provider) from the content (consumer), so the context is available to children.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no TypeScript errors. Verify: (a) ConversationSidebar empty state uses `onNewChat`, (b) ChatLayout exports `useChatLayoutContext`, (c) ChatHubView's inner component calls `useChatLayoutContext().onNewChat` in the action onClick.
  </verify>
  <done>
Both "New Chat" (ChatHubView) and "Start Chat" (ConversationSidebar empty state) buttons open the AgentPickerDialog. The context pattern propagates the callback from ChatLayout to its children without prop drilling.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. AgentPickerDialog no longer has its own TanStack Query call (uses Zustand)
3. "New Chat" in ChatHubView opens AgentPickerDialog via context callback
4. "Start Chat" in ConversationSidebar empty state calls onNewChat prop
5. ChatLayout provides context with onNewChat callback
6. No TODO comments remain about "wired in 04-02"
</verification>

<success_criteria>
- New Chat button in chat hub opens the AgentPickerDialog
- Start Chat button in conversation sidebar empty state opens the AgentPickerDialog
- AgentPickerDialog reads from Zustand (same source as useAgents)
- No query key mismatch exists between agent data consumers
</success_criteria>

<output>
After completion, create `.planning/phases/11-gap-closure-wiring-traceability/11-02-SUMMARY.md`
</output>
